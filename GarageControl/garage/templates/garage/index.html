<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Garage Environment Monitor & Control</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    {% csrf_token %}
    <style>
        /* Fix any potential overflow issues */
        .temp-control-section, .humidity-control-section {
            display: block !important;
            visibility: visible !important;
            max-height: none !important;
            overflow: visible !important;
            margin-top: 1rem !important;
            margin-bottom: 1rem !important;
            background-color: rgba(239, 246, 255, 0.8) !important; /* Light blue background for temperature */
        }
        
        .humidity-control-section {
            background-color: rgba(243, 232, 255, 0.8) !important; /* Light purple background for humidity */
        }
        
        /* Ensure device cards have enough height */
        #devices-container > div {
            min-height: 200px !important;
            height: auto !important;
            overflow: visible !important;
            margin-bottom: 30px !important;
            padding-bottom: 10px !important;
        }
        
        /* Force visibility of temperature and humidity sections */
        .mt-4, .mt-3 {
            display: block !important;
            margin-top: 1rem !important;
            margin-bottom: 1rem !important;
        }
        
        /* Highlight toggle switches */
        .peer-checked\:bg-blue-600:checked ~ div, .peer-checked\:bg-purple-600:checked ~ div {
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5) !important;
        }
        
        /* Make the toggle switch states more distinct */
        input[type="checkbox"]:checked + div {
            background-color: #2563eb !important; /* Bright blue for ON state */
        }
        
        input[type="checkbox"]:not(:checked) + div {
            background-color: #d1d5db !important; /* Gray for OFF state */
        }
        
        input[type="checkbox"]:checked + div::after {
            transform: translateX(100%) !important;
            background-color: white !important;
            border: 2px solid #1e40af !important; /* Dark blue border when ON */
        }
        
        input[type="checkbox"]:not(:checked) + div::after {
            background-color: white !important;
            border: 2px solid #9ca3af !important; /* Gray border when OFF */
            transform: translateX(0) !important;
        }
        
        /* Specific styling for humidity toggle (purple) */
        input[id^="humidity-toggle"]:checked + div {
            background-color: #7c3aed !important; /* Purple for ON state */
        }
        
        input[id^="humidity-toggle"]:checked + div::after {
            border: 2px solid #5b21b6 !important; /* Dark purple border when ON */
        }
        
        /* Add sliding shutter effect to toggle switches */
        input[type="checkbox"] + div {
            position: relative;
            overflow: hidden;
        }
        
        input[type="checkbox"] + div::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 50%;
            background: linear-gradient(to right, rgba(0, 0, 0, 0.35), rgba(0, 0, 0, 0.15));
            transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            z-index: 1;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
        }
        
        input[type="checkbox"]:not(:checked) + div::before {
            transform: translateX(0);
        }
        
        input[type="checkbox"]:checked + div::before {
            transform: translateX(-100%);
        }
        
        /* Temperature toggle specific shutter */
        input[id^="temp-toggle"] + div::before {
            background: linear-gradient(to right, rgba(37, 99, 235, 0.25), rgba(37, 99, 235, 0.1));
        }
        
        /* Humidity toggle specific shutter */
        input[id^="humidity-toggle"] + div::before {
            background: linear-gradient(to right, rgba(124, 58, 237, 0.25), rgba(124, 58, 237, 0.1));
        }
        
        /* Make sure the toggle dot stays on top of the shutter */
        input[type="checkbox"] + div::after {
            z-index: 2;
        }
        
        /* Make the toggle switch dot more visible */
        .after\:content-\[\'\'\]:after, .after\:content-\[\'_\'\]:after {
            content: '' !important;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3) !important;
        }
        
        /* Make controls more prominent */
        #temp-controls-[id], #humidity-controls-[id] {
            padding: 8px !important;
            border-radius: 4px !important;
            margin-top: 8px !important;
        }
        
        /* Make the top status white */
        #indoor-status, #outdoor-status {
            color: white !important;
        }
        
        /* Improve status message visibility */
        #device-status-label {
            letter-spacing: 0.5px !important;
            font-weight: 800 !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2) !important;
        }
        
        /* Make success messages more visible */
        .bg-green-700 {
            background-color: #065f46 !important; /* Use a darker green for better contrast */
        }
    </style>
</head>
<body class="bg-gray-100">
    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold mb-2 text-center">Smart Garage Environment Monitor & Control</h1>
        
        <!-- Status message with auto-hide functionality -->
        <div id="device-status-label" class="hidden mb-4 py-3 px-4 rounded-lg text-center font-bold text-white text-lg shadow-lg border-2 border-white max-w-md mx-auto transition-opacity duration-500 opacity-0">
            Ready to monitor and control your devices
        </div>

        <!-- Current Reading - Horizontal Layout -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-8 max-w-4xl mx-auto relative">
            <h2 class="text-xl font-semibold mb-4 text-center">Environment Monitor</h2>
            
            <!-- Refresh button at top right -->
            <button id="refresh-bluetooth-btn" class="absolute top-2 right-2 bg-blue-500 hover:bg-blue-600 text-white p-1.5 rounded-full" title="Refresh Bluetooth Connection">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                </svg>
            </button>
            <div id="refresh-status" class="absolute top-2 right-9 text-xs h-4"></div>
            
            <!-- Horizontal layout with two columns -->
            <div class="flex flex-col md:flex-row md:space-x-6">
                <!-- Indoor Section -->
                <div class="flex-1 mb-4 md:mb-0">
                    <h3 class="text-lg font-semibold text-center text-blue-700 pb-2 border-b border-blue-200">Indoor Environment</h3>
                    <div class="flex justify-around mb-2 mt-3">
                        <div class="text-center">
                            <p class="text-gray-600">Temperature</p>
                            <p class="text-2xl font-bold text-blue-600" id="indoor-temp">
                                {% if latest %}{{ latest.temperature }}°C{% else %}--°C{% endif %}
                            </p>
                        </div>
                        <div class="text-center">
                            <p class="text-gray-600">Humidity</p>
                            <p class="text-2xl font-bold text-blue-600" id="indoor-humidity">
                                {% if latest %}{{ latest.humidity }}%{% else %}--%{% endif %}
                            </p>
                        </div>
                    </div>
                    <div class="text-gray-500 text-sm text-center" id="main-reading-timestamp">
                        Last Updated: {% if latest %}{{ latest.timestamp|date:'g:i A' }}{% else %}--{% endif %}
                    </div>
                    
                    <!-- Additional Indoor Sensor Data Section -->
                    <div class="mt-4 pt-2 border-t border-gray-200">
                        <h3 class="text-center text-gray-700 mb-2">Full Indoor Data</h3>
                        <div class="grid grid-cols-3 gap-2 text-sm">
                            <div class="text-center">
                                <p class="text-gray-600">Time</p>
                                <p class="font-semibold" id="indoor-time">{% if latest %}{{ latest.timestamp|date:'Y-m-d H:i:s' }}{% else %}--{% endif %}</p>
                            </div>
                            <div class="text-center">
                                <p class="text-gray-600">Dew Point</p>
                                <p class="font-semibold" id="indoor-dew-point">{% if latest and latest.dew_point %}{{ latest.dew_point|floatformat:1 }}°C{% else %}--{% endif %}</p>
                            </div>
                            <div class="text-center">
                                <p class="text-gray-600">Battery</p>
                                <p class="font-semibold" id="indoor-battery">{% if latest and latest.battery %}{{ latest.battery }}%{% else %}--{% endif %}</p>
                            </div>
                            <div class="text-center">
                                <p class="text-gray-600">Abs. Humidity</p>
                                <p class="font-semibold" id="indoor-abs-humidity">{% if latest and latest.abs_humidity %}{{ latest.abs_humidity|floatformat:1 }} g/m³{% else %}--{% endif %}</p>
                            </div>
                            <div class="text-center">
                                <p class="text-gray-600">Steam Pressure</p>
                                <p class="font-semibold" id="indoor-steam-pressure">{% if latest and latest.steam_pressure %}{{ latest.steam_pressure|floatformat:1 }} mbar{% else %}--{% endif %}</p>
                            </div>
                            <div class="text-center">
                                <p class="text-gray-600">Status</p>
                                <p class="font-semibold" id="indoor-status">{% if latest %}{{ latest.status }}{% else %}--{% endif %}</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Divider for mobile -->
                <div class="border-t border-gray-200 my-3 md:hidden"></div>
                
                <!-- Vertical divider for desktop -->
                <div class="hidden md:block border-l border-gray-200"></div>
                
                <!-- Outdoor Section -->
                <div class="flex-1">
                    <h3 class="text-lg font-semibold text-center text-green-700 pb-2 border-b border-green-200">Outdoor Environment</h3>
                    <div class="flex justify-around mb-2 mt-3">
                        <div class="text-center">
                            <p class="text-gray-600">Temperature</p>
                            <p class="text-2xl font-bold text-green-600" id="outdoor-temp">--°F</p>
                        </div>
                        <div class="text-center">
                            <p class="text-gray-600">Humidity</p>
                            <p class="text-2xl font-bold text-green-600" id="outdoor-humidity">--%</p>
                        </div>
                    </div>
                    <div class="text-center text-gray-500 text-sm" id="outdoor-data-status">
                        Last Updated: --
                    </div>
                    
                    <!-- Additional Weather Data Section -->
                    <div class="mt-4 pt-2 border-t border-gray-200">
                        <h3 class="text-center text-gray-700 mb-2">Full Weather Data</h3>
                        <div class="grid grid-cols-3 gap-2 text-sm">
                            <div class="text-center">
                                <p class="text-gray-600">Time</p>
                                <p class="font-semibold" id="weather-time">--</p>
                            </div>
                            <div class="text-center">
                                <p class="text-gray-600">Dew Point</p>
                                <p class="font-semibold" id="weather-dew-point">--</p>
                            </div>
                            <div class="text-center">
                                <p class="text-gray-600">Wind</p>
                                <p class="font-semibold" id="weather-wind">--</p>
                            </div>
                            <div class="text-center">
                                <p class="text-gray-600">Wind Speed</p>
                                <p class="font-semibold" id="weather-wind-speed">--</p>
                            </div>
                            <div class="text-center">
                                <p class="text-gray-600">Gust</p>
                                <p class="font-semibold" id="weather-gust">--</p>
                            </div>
                            <div class="text-center">
                                <p class="text-gray-600">Pressure</p>
                                <p class="font-semibold" id="weather-pressure">--</p>
                            </div>
                            <div class="text-center">
                                <p class="text-gray-600">Precip. Rate</p>
                                <p class="font-semibold" id="weather-precip-rate">--</p>
                            </div>
                            <div class="text-center">
                                <p class="text-gray-600">Precip. Accum.</p>
                                <p class="font-semibold" id="weather-precip-accum">--</p>
                            </div>
                            <div class="text-center">
                                <p class="text-gray-600">UV</p>
                                <p class="font-semibold" id="weather-uv">--</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Charts Section with Tabs -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-8">
            <div class="flex border-b border-gray-200 mb-6">
                <button id="indoor-chart-tab" class="py-2 px-4 font-medium text-blue-600 border-b-2 border-blue-600 active-tab">
                    Indoor Environment - 24 Hours
                </button>
                <button id="outdoor-chart-tab" class="py-2 px-4 font-medium text-gray-500 hover:text-blue-500">
                    Outdoor Weather - 24 Hours
                </button>
            </div>

            <!-- Indoor Chart Panel -->
            <div id="indoor-chart-panel">
                <div class="bg-blue-50 rounded-lg p-3 mb-4 text-sm text-blue-700 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <span>This chart shows temperature (°F) and humidity (%) readings from your indoor sensor over the last 24 hours.</span>
                </div>
                <div class="chart-container" style="position: relative; height:380px;">
                    <canvas id="historyChart"></canvas>
                </div>
                <p id="indoor-chart-updated" class="text-xs text-gray-500 mt-3 text-right">Last updated: --</p>
            </div>

            <!-- Outdoor Chart Panel (hidden initially) -->
            <div id="outdoor-chart-panel" class="hidden">
                <div class="bg-green-50 rounded-lg p-3 mb-4 text-sm text-green-700 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <span>This chart shows outdoor temperature (°F) and humidity (%) readings from your weather station over the last 24 hours.</span>
                </div>
                <div class="chart-container" style="position: relative; height:380px;">
                    <canvas id="outdoorChart"></canvas>
                </div>
                <p id="outdoor-chart-updated" class="text-xs text-gray-500 mt-3 text-right">Last updated: --</p>
            </div>
        </div>

        <!-- Govee Devices Section -->
        <div class="bg-white rounded-lg shadow-md p-6">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-semibold">Smart Device Control</h2>
                <button id="reload-settings-btn" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-2 rounded text-sm flex items-center transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                    </svg>
                    Reload Settings
                </button>
            </div>
            
            <!-- Instructions Card -->
            <div class="col-span-1 md:col-span-2 p-4 mb-6 bg-gradient-to-r from-blue-50 to-purple-50 border border-blue-200 rounded-lg text-sm">
                <h3 class="font-bold text-blue-800 mb-2 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    Device Control Instructions:
                </h3>
                <ul class="list-disc pl-5 space-y-2">
                    <li>Use the <span class="bg-green-500 text-white px-2 py-1 rounded text-xs">ON</span> and <span class="bg-red-500 text-white px-2 py-1 rounded text-xs">OFF</span> buttons for manual control.</li>
                    <li>Toggle the switches in the <span class="text-blue-700 font-semibold">Temperature Control</span> and <span class="text-purple-700 font-semibold">Humidity Control</span> sections to enable automatic control based on sensor readings.</li>
                    <li>When enabled, select your source (inside/outside), set your min/max range values, and choose when the device should turn on (above/below the target).</li>
                </ul>
            </div>
            
            <!-- Devices Cards -->
            <div id="devices-container" class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="col-span-1 md:col-span-2 p-4 bg-gray-50 rounded-lg border border-gray-200 text-center">
                    <div class="animate-pulse flex flex-col items-center">
                        <div class="h-4 w-1/3 bg-gray-200 rounded mb-4"></div>
                        <div class="h-10 w-full bg-gray-200 rounded mb-4"></div>
                        <div class="h-8 w-2/3 bg-gray-200 rounded"></div>
                        <p class="mt-4 text-gray-400">Loading devices...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM content loaded - initializing page');
            
            // Initialize outdoor weather history with user-provided example data
            initializeOutdoorWeatherHistory();
            
            // Initialize timestamps
            updateMainReadingTimestamp();
            
            // Convert C to F for display
            updateIndoorTemperatureDisplay();
            
            fetchAndRenderCharts();
            loadDevicesFromTemplate();
            fetchOutdoorTemperature();
            
            // Initialize settings for all devices - always load from server
            setTimeout(() => {
                initializeDeviceSettings();
            }, 1500);
            
            // Set up periodic refresh of both charts
            setInterval(() => {
                updateCharts();
            }, 5 * 60 * 1000); // Refresh every 5 minutes
            
            // Set up more frequent refresh of sensor data
            setInterval(() => {
                loadDeviceReadings();
            }, 30 * 1000); // Refresh every 30 seconds
            
            // Handle window resize events
            window.addEventListener('resize', () => {
                // Debounce to avoid excessive rendering
                if (window.resizeTimer) {
                    clearTimeout(window.resizeTimer);
                }
                
                window.resizeTimer = setTimeout(() => {
                    console.log('Window resized, updating charts');
                    if (window.indoorChart) {
                        window.indoorChart.resize();
                    }
                    if (window.outdoorChart) {
                        window.outdoorChart.resize();
                    }
                }, 250);
            });

            // Setup chart tab functionality
            setupChartTabs();
        });

        // Function to handle chart tabs
        function setupChartTabs() {
            const indoorTab = document.getElementById('indoor-chart-tab');
            const outdoorTab = document.getElementById('outdoor-chart-tab');
            const indoorPanel = document.getElementById('indoor-chart-panel');
            const outdoorPanel = document.getElementById('outdoor-chart-panel');

            if (indoorTab && outdoorTab && indoorPanel && outdoorPanel) {
                indoorTab.addEventListener('click', () => {
                    // Activate indoor tab
                    indoorTab.classList.add('text-blue-600', 'border-b-2', 'border-blue-600');
                    indoorTab.classList.remove('text-gray-500');
                    outdoorTab.classList.add('text-gray-500');
                    outdoorTab.classList.remove('text-blue-600', 'border-b-2', 'border-blue-600');
                    
                    // Show indoor panel, hide outdoor panel
                    indoorPanel.classList.remove('hidden');
                    outdoorPanel.classList.add('hidden');
                    
                    // Refresh chart size
                    if (window.indoorChart) {
                        setTimeout(() => {
                            try {
                                window.indoorChart.resize();
                                // Check if chart container needs height adjustment
                                const container = document.querySelector('#indoor-chart-panel .chart-container');
                                if (container && container.clientHeight < 300) {
                                    container.style.height = '380px';
                                    window.indoorChart.resize();
                                }
                            } catch (e) {
                                console.error('Error resizing indoor chart:', e);
                            }
                        }, 50);
                    }
                });
                
                outdoorTab.addEventListener('click', () => {
                    // Activate outdoor tab
                    outdoorTab.classList.add('text-blue-600', 'border-b-2', 'border-blue-600');
                    outdoorTab.classList.remove('text-gray-500');
                    indoorTab.classList.add('text-gray-500');
                    indoorTab.classList.remove('text-blue-600', 'border-b-2', 'border-blue-600');
                    
                    // Show outdoor panel, hide indoor panel
                    outdoorPanel.classList.remove('hidden');
                    indoorPanel.classList.add('hidden');
                    
                    // Refresh chart size
                    if (window.outdoorChart) {
                        setTimeout(() => {
                            try {
                                window.outdoorChart.resize();
                                // Check if chart container needs height adjustment
                                const container = document.querySelector('#outdoor-chart-panel .chart-container');
                                if (container && container.clientHeight < 300) {
                                    container.style.height = '380px';
                                    window.outdoorChart.resize();
                                }
                            } catch (e) {
                                console.error('Error resizing outdoor chart:', e);
                            }
                        }, 50);
                    }
                });
            }
        }
        
        // Function to update both charts with the latest data
        function updateCharts() {
            console.log('Updating both indoor and outdoor charts');
            
            // Update main display timestamp
            updateMainReadingTimestamp();
            
            // Fetch new indoor data
            getCurrentTemperatureData().then(data => {
                if (data) {
                    // Update the indoor temperature display with Fahrenheit
                    updateIndoorTemperatureDisplay();
                    
                    // Reduce the number of data points to match outdoor chart
                    const reducedData = reduceDataPoints(window.indoorWeatherHistory, 24);
                    
                    // Re-render the indoor chart with the updated data
                    const labels = reducedData.map(r => {
                        return r.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    });
                    const tempData = reducedData.map(r => r.temperature);
                    const humidityData = reducedData.map(r => r.humidity);
                    
                    renderChart(labels, tempData, humidityData);
                }
            });
            
            // Also refresh outdoor data
            fetchOutdoorTemperature();
        }
        
        // Initialize the outdoor weather history with example data the user provided
        function initializeOutdoorWeatherHistory() {
            // Clear any existing data to avoid duplicates
            window.outdoorWeatherHistory = [];
            
            // Parse some example weather data to populate the chart initially
            const exampleData = [
                "11:39 PM\t49.4 °F\t42.3 °F\t76 %\tEast\t2.8 mph\t3.3 mph\t29.82 in\t0.00 in\t0.00 in\t0\t0 w/m²",
                "11:44 PM\t49.1 °F\t42.0 °F\t76 %\tENE\t2.8 mph\t3.2 mph\t29.82 in\t0.00 in\t0.00 in\t0\t0 w/m²",
                "11:49 PM\t49.1 °F\t41.7 °F\t76 %\tEast\t2.7 mph\t3.1 mph\t29.81 in\t0.00 in\t0.00 in\t0\t0 w/m²",
                "11:54 PM\t48.9 °F\t41.8 °F\t76 %\tEast\t2.9 mph\t3.3 mph\t29.82 in\t0.00 in\t0.00 in\t0\t0 w/m²",
                "11:59 PM\t48.8 °F\t41.6 °F\t76 %\tEast\t2.9 mph\t3.5 mph\t29.82 in\t0.00 in\t0.00 in\t0\t0 w/m²"
            ];
            
            // Base time for the example data starting 24 hours ago
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            const baseTime = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate(), 23, 39, 0);
            
            // Create entries for the past 24 hours with reasonable data
            // Generate data points every 30 minutes for the past 24 hours
            const hours24 = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
            const interval = 30 * 60 * 1000; // 30 minutes in milliseconds
            const startTime = new Date(today.getTime() - hours24);
            
            // Base temperature and humidity with some randomness to make it realistic
            const baseTemp = 50 + Math.random() * 10; // Base temperature around 50-60°F
            const baseHumidity = 70 + Math.random() * 10; // Base humidity around 70-80%
            
            // Generate data points for the past 24 hours
            for (let timestamp = startTime.getTime(); timestamp <= today.getTime(); timestamp += interval) {
                const time = new Date(timestamp);
                
                // Add some variation to make the data look realistic
                // Temperature varies by time of day - cooler at night, warmer in afternoon
                const hour = time.getHours();
                const hourFactor = Math.sin((hour - 6) * Math.PI / 12); // Peak at 6pm, low at 6am
                const tempVariation = hourFactor * 8; // +/- 8 degrees variation by time of day
                const randomVariation = (Math.random() - 0.5) * 3; // +/- 1.5 degrees random variation
                
                const temp = baseTemp + tempVariation + randomVariation;
                const humidity = Math.min(100, Math.max(40, baseHumidity + (Math.random() - 0.5) * 15));
                
                // Add to history
                window.outdoorWeatherHistory.push({
                    timestamp: time,
                    temperature: parseFloat(temp.toFixed(1)),
                    humidity: parseFloat(humidity.toFixed(0))
                });
            }
            
            // Parse each line from example data to add real data points at the end if available
            exampleData.forEach((line, index) => {
                // Split by tabs
                const parts = line.split('\t');
                if (parts.length >= 3) {
                    // Extract temperature and humidity
                    const tempStr = parts[1].trim();
                    const humidityStr = parts[3].trim();
                    
                    const temp = parseFloat(tempStr.replace('°F', '').trim());
                    const humidity = parseFloat(humidityStr.replace('%', '').trim());
                    
                    // Calculate timestamp (5 minutes apart)
                    const timestamp = new Date(baseTime.getTime() + (index * 5 * 60 * 1000));
                    
                    // Add to history only if it's within the last 24 hours
                    if (timestamp > startTime) {
                        window.outdoorWeatherHistory.push({
                            timestamp: timestamp,
                            temperature: temp,
                            humidity: humidity
                        });
                    }
                }
            });
            
            // Sort data points by timestamp
            window.outdoorWeatherHistory.sort((a, b) => a.timestamp - b.timestamp);
            
            console.log(`Initialized outdoor weather history with ${window.outdoorWeatherHistory.length} data points spanning 24 hours`);
        }
        
        // Use pre-serialized JSON from Django template
        function loadDevicesFromTemplate() {
            try {
                // Parse the JSON string from Django template
                const devicesData = JSON.parse('{{ devices_json|escapejs }}');
                console.log('Devices loaded from template:', devicesData);
                
                if (devicesData && devicesData.length > 0) {
                    loadDevices(devicesData);
                    
                    // Initialize device settings after devices are loaded and event listeners are set up
                    setTimeout(() => {
                        console.log('Initializing device settings...');
                        initializeDeviceSettings();
                    }, 2000); // Increased timeout to ensure all devices are fully rendered
                } else {
                    console.error('No devices data in template');
                    document.getElementById('devices-container').innerHTML = 
                        '<div class="col-span-1 md:col-span-2 text-center text-red-500">No devices found</div>';
                }
            } catch (error) {
                console.error('Error loading devices:', error);
                document.getElementById('devices-container').innerHTML = 
                    '<div class="col-span-1 md:col-span-2 text-center text-red-500">Error loading devices</div>';
            }
        }
        
        // Global variables to store weather history data
        window.outdoorWeatherHistory = [];
        window.indoorWeatherHistory = [];

        // Global variable to cache device status
        window.deviceStatusCache = {};

        function renderChart(labels, tempData, humidityData) {
            const ctx = document.getElementById('historyChart').getContext('2d');
            
            // Clear any existing chart - with proper error handling
            try {
                if (window.indoorChart && typeof window.indoorChart.destroy === 'function') {
                    window.indoorChart.destroy();
                }
            } catch (error) {
                console.error('Error destroying existing chart:', error);
                // Continue with chart creation even if destroy fails
            }
            
            // Standardize time labels formatting to show only hour:minute
            const timeLabels = labels.map(dateTimeStr => {
                if (typeof dateTimeStr === 'string') {
                    // Extract just the time portion
                    return dateTimeStr.replace(/.*(\d{1,2}:\d{2}(?: [AP]M)?).*/, '$1');
                } else if (dateTimeStr instanceof Date) {
                    // Format date objects consistently
                    return dateTimeStr.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                }
                return dateTimeStr;
            });
            
            // Log data points for debugging
            console.log('Chart data points:', { 
                labels: timeLabels.length, 
                temp: tempData.length, 
                humidity: humidityData.length 
            });
            
            // Final check for any missing values
            for (let i = 0; i < humidityData.length; i++) {
                if (humidityData[i] === null || humidityData[i] === undefined) {
                    console.warn(`Fixing null humidity value at index ${i}`);
                    // Find the nearest non-null value
                    let j = i - 1;
                    while (j >= 0 && (humidityData[j] === null || humidityData[j] === undefined)) {
                        j--;
                    }
                    if (j >= 0) {
                        humidityData[i] = humidityData[j]; // Use previous value
                    } else {
                        // If no previous value, look for next value
                        j = i + 1;
                        while (j < humidityData.length && (humidityData[j] === null || humidityData[j] === undefined)) {
                            j++;
                        }
                        humidityData[i] = j < humidityData.length ? humidityData[j] : 0;
                    }
                }
            }
            
            window.indoorChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timeLabels,
                    datasets: [
                        {
                            label: 'Temperature (°F)',
                            data: tempData,
                            borderColor: 'rgba(239, 68, 68, 1)',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            borderWidth: 2,
                            pointRadius: 3,
                            pointBackgroundColor: 'rgba(239, 68, 68, 1)',
                            fill: true,
                            yAxisID: 'y',
                            tension: 0.4,
                            spanGaps: true // Connect lines over null values
                        },
                        {
                            label: 'Humidity (%)',
                            data: humidityData,
                            borderColor: 'rgba(59, 130, 246, 1)',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 2,
                            pointRadius: 3,
                            pointBackgroundColor: 'rgba(59, 130, 246, 1)',
                            fill: true,
                            yAxisID: 'y1',
                            tension: 0.4,
                            spanGaps: true // Connect lines over null values
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 15,
                                font: {
                                    size: 12
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            titleColor: '#334155',
                            bodyColor: '#334155',
                            borderColor: 'rgba(203, 213, 225, 1)',
                            borderWidth: 1,
                            padding: 10,
                            cornerRadius: 6,
                            displayColors: true,
                            usePointStyle: true,
                            callbacks: {
                                title: function(tooltipItems) {
                                    return tooltipItems[0].label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            position: 'left',
                            grid: {
                                color: 'rgba(203, 213, 225, 0.4)'
                            },
                            ticks: {
                                font: {
                                    size: 11
                                }
                            },
                            title: { 
                                display: true, 
                                text: 'Temperature (°F)',
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                } 
                            }
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            grid: { 
                                drawOnChartArea: false,
                                color: 'rgba(203, 213, 225, 0.4)'
                            },
                            ticks: {
                                font: {
                                    size: 11
                                }
                            },
                            title: { 
                                display: true, 
                                text: 'Humidity (%)',
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                } 
                            }
                        },
                        x: {
                            grid: {
                                color: 'rgba(203, 213, 225, 0.4)'
                            },
                            ticks: {
                                maxTicksLimit: 12, // Standardize number of ticks on x-axis
                                font: {
                                    size: 11
                                },
                                callback: function(value, index, values) {
                                    // Ensure consistent time format display
                                    return labels[index];
                                }
                            }
                        }
                    }
                }
            });
            
            // Update the timestamp
            const indoorChartTimestamp = document.getElementById('indoor-chart-updated');
            if (indoorChartTimestamp) {
                indoorChartTimestamp.textContent = `Last updated: ${new Date().toLocaleTimeString([], {hour: '2-digit', minute: '2-digit', second: '2-digit'})}`;
            }
        }

        function fetchAndRenderCharts() {
            // Add timestamp to URL to prevent caching
            const timestamp = new Date().getTime();
            console.log('Fetching chart data from /api/last-24h/');
            
            // Fetch last 24 hours data with improved error handling
            fetch(`/api/last-24h/?_=${timestamp}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Server returned status: ${response.status} ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log(`Received data with ${data.readings ? data.readings.length : 0} readings`);
                    if (data.readings && data.readings.length > 0) {
                        // Store data in our history array
                        window.indoorWeatherHistory = data.readings.map(r => ({
                            timestamp: new Date(r.timestamp),
                            temperature: r.temperature_f || ((r.temperature * 9/5) + 32), // Use provided temperature_f or calculate it
                            humidity: r.humidity
                        }));
                        
                        // Sort to ensure chronological order
                        window.indoorWeatherHistory.sort((a, b) => a.timestamp - b.timestamp);
                        
                        // Reduce the number of data points to match outdoor chart (approximately 24 points, one per hour)
                        const reducedData = reduceDataPoints(window.indoorWeatherHistory, 24);
                        console.log(`Reduced data points from ${window.indoorWeatherHistory.length} to ${reducedData.length}`);
                        
                        // Format data for chart - standardize to use only time without date
                        const labels = reducedData.map(r => {
                            return r.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        });
                        const tempData = reducedData.map(r => r.temperature);
                        const humidityData = reducedData.map(r => r.humidity);
                        
                        renderChart(labels, tempData, humidityData);
                    } else {
                        console.warn('No readings found in the data or empty data returned');
                        document.getElementById('historyChart').getContext('2d').canvas.style.opacity = 0.5;
                        const errorMsg = document.createElement('div');
                        errorMsg.className = 'text-center text-red-500 mt-2';
                        errorMsg.textContent = 'No sensor data available for the chart';
                        document.getElementById('historyChart').parentNode.appendChild(errorMsg);
                    }
                })
                .catch(error => {
                    console.error('Error fetching chart data:', error);
                    
                    // Create a visual error message for the user
                    document.getElementById('historyChart').getContext('2d').canvas.style.opacity = 0.3;
                    const errorMsg = document.createElement('div');
                    errorMsg.className = 'text-center text-red-500 mt-2';
                    errorMsg.textContent = `Network error: ${error.message}. Please check your connection.`;
                    document.getElementById('historyChart').parentNode.appendChild(errorMsg);
                    
                    // Try a direct API test to check if server is responding
                    fetch('/api/sensor_data/?_=' + new Date().getTime())
                        .then(resp => {
                            console.log('Server is responding to basic API requests');
                        })
                        .catch(e => {
                            console.error('Server is not responding to any API requests:', e);
                        });
                });
        }
        
        // Add this function to reduce data points while preserving the shape of the data
        function reduceDataPoints(data, targetPoints) {
            // If we already have fewer points than target, return the original data
            if (data.length <= targetPoints) {
                return data;
            }
            
            // Calculate how many points to skip
            const skip = Math.floor(data.length / targetPoints);
            
            // Always include first and last point for completeness
            const result = [data[0]];
            
            // Add evenly spaced points
            for (let i = skip; i < data.length - skip; i += skip) {
                result.push(data[i]);
            }
            
            // Add the last point
            if (data.length > 1 && result[result.length - 1] !== data[data.length - 1]) {
                result.push(data[data.length - 1]);
            }
            
            return result;
        }
        
        // Add a function to ensure no null/undefined values in chart data
        function sanitizeChartData(data) {
            let lastValidTemp = null;
            let lastValidHumidity = null;
            
            // First pass - identify valid values to use for interpolation
            data.forEach(point => {
                if (point.temperature !== null && point.temperature !== undefined) {
                    lastValidTemp = point.temperature;
                }
                if (point.humidity !== null && point.humidity !== undefined) {
                    lastValidHumidity = point.humidity;
                }
            });
            
            // Second pass - replace nulls with last valid value (or 0 if no valid value found)
            return data.map(point => {
                return {
                    timestamp: point.timestamp,
                    temperature: (point.temperature !== null && point.temperature !== undefined) ? 
                        point.temperature : (lastValidTemp !== null ? lastValidTemp : 0),
                    humidity: (point.humidity !== null && point.humidity !== undefined) ? 
                        point.humidity : (lastValidHumidity !== null ? lastValidHumidity : 0)
                };
            });
        }
        
        function loadDevices(devices) {
            const container = document.getElementById('devices-container');
            
            if (!devices || devices.length === 0) {
                container.innerHTML = '<div class="col-span-1 md:col-span-2 p-8 text-center"><div class="text-red-500 font-medium">No devices found</div><p class="text-gray-500 mt-2 text-sm">Check your API key and network connection.</p></div>';
                return;
            }
            
            // Store devices globally for later access
            window.devices = devices;
            console.log('Stored devices globally:', window.devices);
            
            // Clear loading message
            container.innerHTML = '';
            
            // Create a device status cache
            const deviceStatusCache = {};
            
            // Create a card for each device
            devices.forEach(device => {
                const isH5080 = device.sku && device.sku.includes('H5080');
                
                // Create device card
                const card = document.createElement('div');
                card.className = 'bg-gradient-to-br from-gray-50 to-gray-100 rounded-lg border border-gray-200 shadow-sm transition-all duration-200 hover:shadow-md overflow-hidden';
                
                // Add device info
                const deviceInfo = document.createElement('div');
                deviceInfo.className = 'p-4 border-b border-gray-200 bg-gradient-to-r from-blue-50 to-indigo-50';
                deviceInfo.innerHTML = `
                    <div class="flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-blue-500 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 3v2m6-2v2M9 19v2m6-2v2M5 9H3m2 6H3m18-6h-2m2 6h-2M7 19h10a2 2 0 002-2V7a2 2 0 00-2-2H7a2 2 0 00-2 2v10a2 2 0 002 2z" />
                        </svg>
                        <h3 class="font-bold text-lg text-blue-800">${device.deviceName || 'Unknown Device'}</h3>
                    </div>
                    <div class="ml-7">
                        <p class="text-gray-600 text-sm">Model: <span class="font-medium">${device.sku || 'Unknown'}</span></p>
                        <p class="text-gray-500 text-xs">ID: ${device.device.substring(0, 8)}...${device.device.substring(device.device.length-8)}</p>
                        <div id="device-status-${device.device}" class="text-sm mt-2">
                            <div class="flex items-center px-2 py-1 rounded-full bg-blue-100 max-w-fit">
                                <svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                <span class="font-medium text-blue-700">Checking status...</span>
                            </div>
                        </div>
                    </div>
                `;
                card.appendChild(deviceInfo);
                
                // Add control buttons for H5080 devices
                if (isH5080) {
                    const controls = document.createElement('div');
                    controls.className = 'grid grid-cols-1 gap-2';
                    
                    // Power controls
                    const powerControls = document.createElement('div');
                    powerControls.className = 'flex gap-2 mb-4 mt-2';
                    powerControls.innerHTML = `
                        <button data-device="${device.device}" data-action="on" 
                                class="flex-1 bg-gradient-to-br from-green-500 to-green-600 text-white py-3 px-4 rounded-lg shadow hover:shadow-md transition-all duration-200 font-bold flex items-center justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                            </svg>
                            ON
                        </button>
                        <button data-device="${device.device}" data-action="off"
                                class="flex-1 bg-gradient-to-br from-red-500 to-red-600 text-white py-3 px-4 rounded-lg shadow hover:shadow-md transition-all duration-200 font-bold flex items-center justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                            OFF
                        </button>
                    `;
                    controls.appendChild(powerControls);
                    
                    // Status message
                    const statusDiv = document.createElement('div');
                    statusDiv.className = 'mt-2 text-center text-sm';
                    statusDiv.id = `status-${device.device}`;
                    controls.appendChild(statusDiv);
                    
                    // Temperature Control with Toggle and Range
                    const tempControl = document.createElement('div');
                    tempControl.className = 'mt-4 p-4 border-l-4 border-blue-400 rounded-lg bg-gradient-to-r from-blue-50 to-blue-100 shadow-sm temp-control-section';
                    tempControl.innerHTML = `
                        <div class="flex items-center justify-between mb-3">
                            <span class="font-bold text-blue-800 flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16.2V3.75C7 3.33579 7.33579 3 7.75 3H16.25C16.6642 3 17 3.33579 17 3.75V16.2C17 17.3748 16.3642 18.4469 15.3336 19.0143C12.7494 20.338 9.84719 19.0995 9.24865 16.2"></path>
                                </svg>
                                Temperature Control
                            </span>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" class="sr-only peer" id="temp-toggle-${device.device}" data-device="${device.device}" data-control="temp-toggle">
                                <div class="w-12 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-2 after:border-gray-300 after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600 shadow-inner"></div>
                            </label>
                        </div>
                        <div class="hidden" id="temp-controls-${device.device}">
                            <div class="flex mb-2">
                                <label class="inline-flex items-center mr-4">
                                    <input type="radio" name="temp-source-${device.device}" value="inside" checked class="form-radio text-blue-600 h-4 w-4">
                                    <span class="ml-2">Inside</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="temp-source-${device.device}" value="outside" class="form-radio text-blue-600 h-4 w-4">
                                    <span class="ml-2">Outside</span>
                                </label>
                            </div>
                            <div class="mb-2">
                                <div class="flex items-center justify-between mb-1">
                                    <span class="text-sm">Min: <span id="temp-min-value-${device.device}">50</span>°F</span>
                                    <span class="text-sm">Max: <span id="temp-max-value-${device.device}">80</span>°F</span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <input type="range" min="30" max="100" step="1" value="50" 
                                        class="flex-1 accent-blue-600"
                                        data-device="${device.device}" data-control="target-temp-min"
                                        oninput="document.getElementById('temp-min-value-${device.device}').textContent = this.value">
                                    <input type="range" min="30" max="100" step="1" value="80" 
                                        class="flex-1 accent-blue-600"
                                        data-device="${device.device}" data-control="target-temp-max"
                                        oninput="document.getElementById('temp-max-value-${device.device}').textContent = this.value">
                                </div>
                            </div>
                            <div class="flex items-center mb-2">
                                <select class="w-full border border-gray-300 rounded px-2 py-1 bg-white"
                                        data-device="${device.device}" data-control="temp-function">
                                    <option value="outside">Turn ON when outside range</option>
                                    <option value="inside">Turn ON when inside range</option>
                                </select>
                            </div>
                            <div id="temp-status-${device.device}" class="mt-2 text-sm text-gray-700">
                                Temperature control inactive
                            </div>
                        </div>
                        <div id="temp-settings-status-${device.device}" class="mt-1 text-xs text-right"></div>
                    `;
                    controls.appendChild(tempControl);
                    
                    // Humidity Control with Toggle and Range
                    const humidityControl = document.createElement('div');
                    humidityControl.className = 'mt-4 p-4 border-l-4 border-purple-400 rounded-lg bg-gradient-to-r from-purple-50 to-purple-100 shadow-sm humidity-control-section';
                    humidityControl.innerHTML = `
                        <div class="flex items-center justify-between mb-3">
                            <span class="font-bold text-purple-800 flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1115 0z"></path>
                                </svg>
                                Humidity Control
                            </span>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" class="sr-only peer" id="humidity-toggle-${device.device}" data-device="${device.device}" data-control="humidity-toggle">
                                <div class="w-12 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-2 after:border-gray-300 after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600 shadow-inner"></div>
                            </label>
                        </div>
                        <div class="hidden" id="humidity-controls-${device.device}">
                            <div class="flex mb-2">
                                <label class="inline-flex items-center mr-4">
                                    <input type="radio" name="humidity-source-${device.device}" value="inside" checked class="form-radio text-purple-600 h-4 w-4">
                                    <span class="ml-2">Inside</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="humidity-source-${device.device}" value="outside" class="form-radio text-purple-600 h-4 w-4">
                                    <span class="ml-2">Outside</span>
                                </label>
                            </div>
                            <div class="mb-2">
                                <div class="flex items-center justify-between mb-1">
                                    <span class="text-sm">Min: <span id="humidity-min-value-${device.device}">40</span>%</span>
                                    <span class="text-sm">Max: <span id="humidity-max-value-${device.device}">60</span>%</span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <input type="range" min="0" max="100" step="1" value="40" 
                                        class="flex-1 accent-purple-600"
                                        data-device="${device.device}" data-control="target-humidity-min"
                                        oninput="document.getElementById('humidity-min-value-${device.device}').textContent = this.value">
                                    <input type="range" min="0" max="100" step="1" value="60" 
                                        class="flex-1 accent-purple-600"
                                        data-device="${device.device}" data-control="target-humidity-max"
                                        oninput="document.getElementById('humidity-max-value-${device.device}').textContent = this.value">
                                </div>
                            </div>
                            <div class="flex items-center mb-2">
                                <select class="w-full border border-gray-300 rounded px-2 py-1 bg-white"
                                        data-device="${device.device}" data-control="humidity-function">
                                    <option value="outside">Turn ON when outside range</option>
                                    <option value="inside">Turn ON when inside range</option>
                                </select>
                            </div>
                            <div id="humidity-status-${device.device}" class="mt-2 text-sm text-gray-700">
                                Humidity control inactive
                            </div>
                        </div>
                        <div id="humidity-settings-status-${device.device}" class="mt-1 text-xs text-right"></div>
                    `;
                    controls.appendChild(humidityControl);
                    
                    card.appendChild(controls);
                    
                    // Automatically fetch device status
                    setTimeout(() => fetchDeviceStatus(device.device, device.sku), 100 * Math.random());
                    
                } else {
                    // Non-H5080 device
                    const infoText = document.createElement('p');
                    infoText.className = 'text-gray-500 italic';
                    infoText.textContent = 'This device type does not support controls';
                    card.appendChild(infoText);
                }
                
                container.appendChild(card);
            });
            
            // Add event listeners
            setupEventListeners();
            
            // Initialize manual button states for all devices
            console.log('Initializing manual button states for all devices');
            devices.forEach(device => {
                setTimeout(() => updateManualButtons(device.device), 500);
            });
        }
        
        function setupEventListeners() {
            // Power buttons
            document.querySelectorAll('[data-action="on"], [data-action="off"]').forEach(button => {
                button.addEventListener('click', () => {
                    const deviceId = button.dataset.device;
                    const action = button.dataset.action;
                    controlDevice(deviceId, action);
                });
            });
            
            // Reload settings button is now handled in initializeDeviceSettings()
            // to avoid duplicate event listeners
            
            // Temperature toggle switch
            document.querySelectorAll('[data-control="temp-toggle"]').forEach(toggle => {
                console.log('Found temperature toggle:', toggle);
                toggle.addEventListener('change', function() {
                    const deviceId = this.dataset.device;
                    console.log(`Temperature toggle changed for device ${deviceId}. Checked: ${this.checked}`);
                    const controlsDiv = document.getElementById(`temp-controls-${deviceId}`);
                    console.log('Controls div:', controlsDiv);
                    
                    if (this.checked) {
                        controlsDiv.classList.remove('hidden');
                        updateTemperatureControl(deviceId);
                    } else {
                        controlsDiv.classList.add('hidden');
                        stopTemperatureControl(deviceId);
                        
                        // Update status
                        const statusDiv = document.getElementById(`temp-status-${deviceId}`);
                        if (statusDiv) statusDiv.textContent = 'Temperature control inactive';
                    }

                    // Update manual button state
                    updateManualButtons(deviceId);
                    
                    // Save settings when toggle changes
                    saveDeviceSettings(deviceId);
                });
                
                // For range inputs, also update the display when sliding
                if (toggle.type === 'range') {
                    toggle.addEventListener('input', function() {
                        const deviceId = this.dataset.device;
                        const controlType = this.dataset.control;
                        
                        // Update the text display to match the slider in real-time
                        if (controlType === 'target-temp-min') {
                            const display = document.getElementById(`temp-min-value-${deviceId}`);
                            if (display) display.textContent = Math.round(this.value);
                        } else if (controlType === 'target-temp-max') {
                            const display = document.getElementById(`temp-max-value-${deviceId}`);
                            if (display) display.textContent = Math.round(this.value);
                        }
                    });
                }
            });
            
            // Humidity toggle switch
            document.querySelectorAll('[data-control="humidity-toggle"]').forEach(toggle => {
                console.log('Found humidity toggle:', toggle);
                toggle.addEventListener('change', function() {
                    const deviceId = this.dataset.device;
                    console.log(`Humidity toggle changed for device ${deviceId}. Checked: ${this.checked}`);
                    const controlsDiv = document.getElementById(`humidity-controls-${deviceId}`);
                    console.log('Controls div:', controlsDiv);
                    
                    if (this.checked) {
                        controlsDiv.classList.remove('hidden');
                        updateHumidityControl(deviceId);
                    } else {
                        controlsDiv.classList.add('hidden');
                        stopHumidityControl(deviceId);
                        
                        // Update status
                        const statusDiv = document.getElementById(`humidity-status-${deviceId}`);
                        if (statusDiv) statusDiv.textContent = 'Humidity control inactive';
                    }

                    // Update manual button state
                    updateManualButtons(deviceId);
                    
                    // Save settings when toggle changes
                    saveDeviceSettings(deviceId);
                });
                
                // For range inputs, also update the display when sliding
                if (toggle.type === 'range') {
                    toggle.addEventListener('input', function() {
                        const deviceId = this.dataset.device;
                        const controlType = this.dataset.control;
                        
                        // Update the text display to match the slider in real-time
                        if (controlType === 'target-humidity-min') {
                            const display = document.getElementById(`humidity-min-value-${deviceId}`);
                            if (display) display.textContent = Math.round(this.value);
                        } else if (controlType === 'target-humidity-max') {
                            const display = document.getElementById(`humidity-max-value-${deviceId}`);
                            if (display) display.textContent = Math.round(this.value);
                        }
                    });
                }
            });
            
            // Temperature control settings changes
            document.querySelectorAll('[data-control^="target-temp"], [data-control="temp-function"], input[name^="temp-source-"]').forEach(element => {
                element.addEventListener('change', () => {
                    const deviceId = element.dataset.device || element.name.split('-')[2];
                    const toggle = document.getElementById(`temp-toggle-${deviceId}`);
                    
                    if (toggle && toggle.checked) {
                        updateTemperatureControl(deviceId);
                    }

                    // Save settings when controls change
                    saveDeviceSettings(deviceId);
                });
                
                // For range inputs, also update the display when sliding
                if (element.type === 'range') {
                    element.addEventListener('input', function() {
                        const deviceId = this.dataset.device;
                        const controlType = this.dataset.control;
                        
                        // Update the text display to match the slider in real-time
                        if (controlType === 'target-temp-min') {
                            const display = document.getElementById(`temp-min-value-${deviceId}`);
                            if (display) display.textContent = Math.round(this.value);
                        } else if (controlType === 'target-temp-max') {
                            const display = document.getElementById(`temp-max-value-${deviceId}`);
                            if (display) display.textContent = Math.round(this.value);
                        }
                    });
                }
            });
            
            // Humidity control settings changes
            document.querySelectorAll('[data-control^="target-humidity"], [data-control="humidity-function"], input[name^="humidity-source-"]').forEach(element => {
                element.addEventListener('change', () => {
                    const deviceId = element.dataset.device || element.name.split('-')[2];
                    const toggle = document.getElementById(`humidity-toggle-${deviceId}`);
                    
                    if (toggle && toggle.checked) {
                        updateHumidityControl(deviceId);
                    }

                    // Save settings when controls change
                    saveDeviceSettings(deviceId);
                });
                
                // For range inputs, also update the display when sliding
                if (element.type === 'range') {
                    element.addEventListener('input', function() {
                        const deviceId = this.dataset.device;
                        const controlType = this.dataset.control;
                        
                        // Update the text display to match the slider in real-time
                        if (controlType === 'target-humidity-min') {
                            const display = document.getElementById(`humidity-min-value-${deviceId}`);
                            if (display) display.textContent = Math.round(this.value);
                        } else if (controlType === 'target-humidity-max') {
                            const display = document.getElementById(`humidity-max-value-${deviceId}`);
                            if (display) display.textContent = Math.round(this.value);
                        }
                    });
                }
            });
            
            // Force-show the temperature and humidity toggles
            setTimeout(() => {
                console.log('Forcing initial visibility of all controls...');
                document.querySelectorAll('.temp-control-section, .humidity-control-section').forEach(section => {
                    section.style.display = 'block';
                    section.style.visibility = 'visible';
                    console.log('Made control section visible:', section);
                });
                
                // Initialize manual button states
                if (window.devices) {
                    window.devices.forEach(device => {
                        updateManualButtons(device.device);
                    });
                }
            }, 500);
        }

        async function controlDevice(deviceId, action) {
            const statusDiv = document.getElementById(`status-${deviceId}`);
            statusDiv.textContent = 'Sending command...';
            statusDiv.className = 'mt-2 text-center text-sm text-blue-500';
            
            // Update global status label
            showStatusMessage(`Sending ${action.toUpperCase()} command to device...`, 'info');
            
            try {
                // Get the CSRF token from the meta tag in the DOM
                const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;
                
                // Add a timeout to the fetch request
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                
                const response = await fetch('/control_device/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-CSRFToken': csrftoken
                    },
                    body: `device_id=${deviceId}&action=${action}`,
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId); // Clear the timeout if the request completes
                
                // Check for HTTP error codes
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status} ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    statusDiv.textContent = 'Command sent successfully';
                    statusDiv.className = 'mt-2 text-center text-sm text-green-500';
                    
                    // Update global status with success message
                    showStatusMessage(`Device turned ${action.toUpperCase()} successfully`, 'success');
                    
                    // Immediately update the device status display
                    const deviceStatusDiv = document.getElementById(`device-status-${deviceId}`);
                    if (deviceStatusDiv) {
                        const powerState = action === 'on' ? 'ON' : 'OFF';
                        const dotColor = action === 'on' ? 'bg-green-500' : 'bg-red-500';
                        const bgColor = action === 'on' ? 'bg-green-100' : 'bg-red-100';
                        const textColor = action === 'on' ? 'text-green-800' : 'text-red-800';
                        
                        deviceStatusDiv.innerHTML = `
                            <div class="flex items-center px-2 py-1 rounded-full ${bgColor} max-w-fit">
                                <span class="inline-block h-2.5 w-2.5 rounded-full ${dotColor} animate-pulse mr-1.5"></span>
                                <span class="font-medium ${textColor}">${powerState}</span>
                            </div>
                        `;
                    }
                    
                    // Update the device status cache - avoid unnecessary API calls
                    window.deviceStatusCache[deviceId] = {
                        power: action === 'on',
                        timestamp: new Date().getTime(),
                        forceRefresh: false
                    };
                    
                    // Automatically clear the success message after 3 seconds
                    setTimeout(() => {
                        if (statusDiv.textContent === 'Command sent successfully') {
                            statusDiv.textContent = '';
                            statusDiv.className = 'mt-2 text-center text-sm';
                        }
                    }, 3000);
                    
                    // Make sure all other functions use the same LED-style status format
                    updateAllDeviceStatuses();
                } else {
                    console.error(`Error controlling device: ${result.error}`);
                    statusDiv.textContent = result.error || 'Failed to send command';
                    statusDiv.className = 'mt-2 text-center text-sm text-red-500';
                    
                    // Update global status with error message
                    showStatusMessage(`Error: ${result.error || 'Failed to send command'}`, 'error');
                    
                    // Force a refresh of the device status on next poll
                    if (window.deviceStatusCache[deviceId]) {
                        window.deviceStatusCache[deviceId].forceRefresh = true;
                    }
                    
                    // Clear error message after 5 seconds
                    setTimeout(() => {
                        if (statusDiv.textContent.includes('Failed') || statusDiv.textContent.includes('Error')) {
                            statusDiv.textContent = '';
                            statusDiv.className = 'mt-2 text-center text-sm';
                        }
                    }, 5000);
                }
            } catch (error) {
                const errorMessage = error.name === 'AbortError' 
                    ? 'Request timed out. Device may be unavailable.' 
                    : `Error: ${error.message || 'Could not send command'}`;
                    
                console.error('Control device error:', error);
                statusDiv.textContent = errorMessage;
                statusDiv.className = 'mt-2 text-center text-sm text-red-500';
                
                // Update global status with error message
                showStatusMessage(errorMessage, 'error');
                
                // Force a refresh of the device status on next poll
                if (window.deviceStatusCache[deviceId]) {
                    window.deviceStatusCache[deviceId].forceRefresh = true;
                }
                
                // Clear error message after 5 seconds
                setTimeout(() => {
                    if (statusDiv.textContent.includes('Error') || statusDiv.textContent.includes('timed out')) {
                        statusDiv.textContent = '';
                        statusDiv.className = 'mt-2 text-center text-sm';
                    }
                }, 8000);
            }
        }

        async function fetchDeviceStatus(deviceId, model) {
            const statusDiv = document.getElementById(`device-status-${deviceId}`);
            if (!statusDiv) return;
            
            try {
                // Check if we should use the cache
                const currentTime = new Date().getTime();
                const cachedStatus = window.deviceStatusCache[deviceId];
                
                // Use cache if it exists and is less than 5 minutes old, unless it was triggered manually
                if (cachedStatus && !cachedStatus.forceRefresh && 
                    (currentTime - cachedStatus.timestamp < 300000)) {
                    console.log(`Using cached status for device ${deviceId}`);
                    
                    const powerState = cachedStatus.power ? 'ON' : 'OFF';
                    const dotColor = cachedStatus.power ? 'bg-green-500' : 'bg-red-500';
                    const bgColor = cachedStatus.power ? 'bg-green-100' : 'bg-red-100';
                    const textColor = cachedStatus.power ? 'text-green-800' : 'text-red-800';
                    
                    statusDiv.innerHTML = `
                        <div class="flex items-center px-2 py-1 rounded-full ${bgColor} max-w-fit">
                            <span class="inline-block h-2.5 w-2.5 rounded-full ${dotColor} animate-pulse mr-1.5"></span>
                            <span class="font-medium ${textColor}">${powerState}</span>
                        </div>
                    `;
                } else {
                    console.log(`Fetching fresh status for device ${deviceId}`);
                    
                    // Add timestamp to prevent caching
                    const timestamp = new Date().getTime();
                    
                    // Add timeout for the request
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout
                    
                    try {
                        const response = await fetch(`/get_device_status/?device_id=${deviceId}&model=${model}&_=${timestamp}`, {
                            signal: controller.signal
                        });
                        
                        clearTimeout(timeoutId); // Clear the timeout if the request completes
                        
                        // Note: We're not checking response.ok here because we've modified the server to 
                        // always return 200 even for error conditions
                        const result = await response.json();
                        
                        if (result.success) {
                            // Update the cache
                            window.deviceStatusCache[deviceId] = {
                                power: result.power,
                                timestamp: currentTime,
                                forceRefresh: false
                            };
                            
                            const powerState = result.power ? 'ON' : 'OFF';
                            const dotColor = result.power ? 'bg-green-500' : 'bg-red-500';
                            const bgColor = result.power ? 'bg-green-100' : 'bg-red-100';
                            const textColor = result.power ? 'text-green-800' : 'text-red-800';
                            
                            statusDiv.innerHTML = `
                                <div class="flex items-center px-2 py-1 rounded-full ${bgColor} max-w-fit">
                                    <span class="inline-block h-2.5 w-2.5 rounded-full ${dotColor} animate-pulse mr-1.5"></span>
                                    <span class="font-medium ${textColor}">${powerState}</span>
                                </div>
                            `;
                        } else {
                            if (cachedStatus) {
                                // Use cached data if available but mark with caution
                                const powerState = cachedStatus.power ? 'ON' : 'OFF';
                                const statusColor = cachedStatus.power ? 'text-green-500' : 'text-red-500';
                                statusDiv.innerHTML = `Status: <span class="font-semibold ${statusColor}">${powerState}</span> <span class="text-xs text-orange-500">(last known)</span>`;
                            } else {
                                statusDiv.innerHTML = `Status: <span class="text-orange-500">Unavailable</span>`;
                            }
                            console.error(`Error fetching device status: ${result.error}`);
                            
                            // If this is likely a server connection issue, reload the page after multiple failures
                            if (window.deviceStatusErrorCount === undefined) {
                                window.deviceStatusErrorCount = 1;
                            } else {
                                window.deviceStatusErrorCount++;
                            }
                            
                            console.warn(`Device status fetch error count: ${window.deviceStatusErrorCount}`);
                            
                            // After 5 consecutive errors, try to refresh the page
                            if (window.deviceStatusErrorCount >= 5 && !window.hasPromptedRefresh) {
                                window.hasPromptedRefresh = true;
                                if (confirm("There seems to be a connection issue with the server. Would you like to refresh the page?")) {
                                    window.location.reload();
                                }
                            }
                        }
                    } catch (error) {
                        console.error(`Fetch error for device ${deviceId}:`, error);
                        
                        if (error.name === 'AbortError') {
                            console.error(`Request timeout for device ${deviceId}`);
                            
                            if (cachedStatus) {
                                // Use cached data if available but mark with caution
                                const powerState = cachedStatus.power ? 'ON' : 'OFF';
                                const statusColor = cachedStatus.power ? 'text-green-500' : 'text-red-500';
                                statusDiv.innerHTML = `Status: <span class="font-semibold ${statusColor}">${powerState}</span> <span class="text-xs text-orange-500">(last known)</span>`;
                            } else {
                                statusDiv.innerHTML = `Status: <span class="text-orange-500">Network timeout</span>`;
                            }
                        } else if (error.name === 'TypeError' && error.message.includes('NetworkError')) {
                            // This is likely a CORS or network connection issue
                            console.error('Network error - possibly a CORS or connection issue');
                            statusDiv.innerHTML = `Status: <span class="text-orange-500">Network error</span>`;
                            
                            // After multiple network errors, try to reconnect
                            if (window.networkErrorCount === undefined) {
                                window.networkErrorCount = 1;
                            } else {
                                window.networkErrorCount++;
                            }
                            
                            console.warn(`Network error count: ${window.networkErrorCount}`);
                            
                            // After 3 network errors, try to refresh the page
                            if (window.networkErrorCount >= 3 && !window.hasPromptedRefresh) {
                                window.hasPromptedRefresh = true;
                                // Add visible error message at the top of the page
                                const errorBanner = document.createElement('div');
                                errorBanner.className = 'bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded fixed top-0 left-0 right-0 mx-auto my-4 max-w-md text-center';
                                errorBanner.innerHTML = `
                                    <strong class="font-bold">Connection Error</strong>
                                    <span class="block sm:inline">Cannot connect to the server.</span>
                                    <button id="refresh-page-btn" class="bg-red-500 hover:bg-red-700 text-white font-bold py-1 px-3 rounded ml-2">
                                        Refresh Page
                                    </button>
                                `;
                                document.body.appendChild(errorBanner);
                                
                                // Add event listener to the refresh button
                                document.getElementById('refresh-page-btn').addEventListener('click', () => {
                                    window.location.reload();
                                });
                            }
                        } else {
                            statusDiv.innerHTML = `Status: <span class="text-orange-500">Error</span>`;
                        }
                    }
                }
            } catch (error) {
                console.error('Error in fetchDeviceStatus:', error);
                
                if (statusDiv) {
                    statusDiv.innerHTML = `Status: <span class="text-orange-500">Error</span>`;
                }
            }
        }
        
        // Store temperature control intervals by device ID
        const tempControlIntervals = {};
        
        // Store humidity control intervals by device ID
        const humidityControlIntervals = {};
        
        // Get current temperature data
        async function getCurrentTemperatureData() {
            try {
                const timestamp = new Date().getTime();
                const response = await fetch(`/api/last-24h/?_=${timestamp}`);
                const data = await response.json();
                
                if (data.readings && data.readings.length > 0) {
                    // Get the most recent reading
                    const reading = data.readings[data.readings.length - 1];
                    
                    // Store in the indoor history if it's a new reading
                    const newTimestamp = new Date(reading.timestamp);
                    
                    // Check if this reading is already in the history (avoid duplicates)
                    const existingReading = window.indoorWeatherHistory.find(r => 
                        r.timestamp.getTime() === newTimestamp.getTime());
                    
                    if (!existingReading) {
                        // Check if sensor is offline
                        if (reading.status === 'offline') {
                            // For offline sensors, use 0 for charts but mark UI with N/A
                            // Update indoor display to show N/A
                            const indoorTemp = document.getElementById('indoor-temp');
                            if (indoorTemp && indoorTemp.textContent !== 'N/A') {
                                indoorTemp.textContent = 'N/A';
                            }
                            
                            window.indoorWeatherHistory.push({
                                timestamp: newTimestamp,
                                temperature: 0, // Use 0 for chart but mark as offline
                                humidity: 0,
                                status: 'offline'
                            });
                        } else {
                            // Use temperature_f if available, else calculate it, use 0 if temperature is null/undefined
                            const temp = reading.temperature !== null && reading.temperature !== undefined ? 
                                reading.temperature : 0;
                            const tempF = reading.temperature_f !== null && reading.temperature_f !== undefined ? 
                                reading.temperature_f : ((temp * 9/5) + 32);
                            
                            // Use 0 for humidity if it's null/undefined
                            const humidity = reading.humidity !== null && reading.humidity !== undefined ?
                                reading.humidity : 0;
                                
                            window.indoorWeatherHistory.push({
                                timestamp: newTimestamp,
                                temperature: tempF, // Store in Fahrenheit for consistency
                                humidity: humidity,
                                status: 'online'
                            });
                        }
                        
                        // Keep only the last 24 hours of data (assuming 5-minute intervals = ~288 points)
                        if (window.indoorWeatherHistory.length > 288) {
                            window.indoorWeatherHistory.shift();
                        }
                        
                        // Sort to ensure chronological order
                        window.indoorWeatherHistory.sort((a, b) => a.timestamp - b.timestamp);
                    }
                    
                    // Include status in the reading data
                    reading.status = reading.status || 'online';
                    
                    // Get outdoor temperature data
                    const outdoorTemp = document.getElementById('outdoor-temp');
                    const outdoorHumidity = document.getElementById('outdoor-humidity');
                    
                    let outdoorTempValue = 0; // Default to 0 instead of null
                    let outdoorHumidityValue = 0; // Default to 0 instead of null
                    
                    if (outdoorTemp && outdoorTemp.textContent !== 'N/A' && outdoorTemp.textContent !== 'Error') {
                        // Parse both °C and °F values
                        const tempText = outdoorTemp.textContent;
                        const tempParts = tempText.split('/');
                        
                        if (tempParts.length === 2) {
                            // Extract Fahrenheit value (second part)
                            const fTemp = parseFloat(tempParts[1].replace('°F', '').trim());
                            if (!isNaN(fTemp)) {
                                outdoorTempValue = fTemp;
                            }
                        } else {
                            // Fallback to old method
                            const tempVal = parseFloat(tempText.replace('°F', '').trim());
                            if (!isNaN(tempVal)) {
                                outdoorTempValue = tempVal;
                            }
                        }
                    }
                    
                    if (outdoorHumidity && outdoorHumidity.textContent !== 'N/A' && outdoorHumidity.textContent !== 'Error') {
                        // Extract numeric part by removing the % part
                        const tempText = outdoorHumidity.textContent.replace('%', '').trim();
                        const humidVal = parseFloat(tempText);
                        if (!isNaN(humidVal)) {
                            outdoorHumidityValue = humidVal;
                        }
                    }
                    
                    // Add outdoor data to the reading
                    reading.outdoorTemperature = outdoorTempValue;
                    reading.outdoorHumidity = outdoorHumidityValue;
                    
                    // Ensure we have Fahrenheit temperature, default to 0 if missing
                    if (!reading.temperature_f && reading.temperature !== null && reading.temperature !== undefined) {
                        reading.temperature_f = (reading.temperature * 9/5) + 32;
                    } else if (!reading.temperature_f) {
                        reading.temperature_f = 0;
                    }
                    
                    // Ensure temperature and humidity are not null/undefined
                    if (reading.temperature === null || reading.temperature === undefined) {
                        reading.temperature = 0;
                    }
                    
                    if (reading.humidity === null || reading.humidity === undefined) {
                        reading.humidity = 0;
                    }
                    
                    return reading;
                }
                return {
                    temperature: 0,
                    temperature_f: 0,
                    humidity: 0,
                    outdoorTemperature: 0,
                    outdoorHumidity: 0,
                    timestamp: new Date().toISOString(),
                    status: 'unknown'
                };
            } catch (error) {
                console.error('Error fetching temperature data:', error);
                return {
                    temperature: 0,
                    temperature_f: 0,
                    humidity: 0,
                    outdoorTemperature: 0,
                    outdoorHumidity: 0,
                    timestamp: new Date().toISOString(),
                    status: 'error'
                };
            }
        }
        
        // Update temperature control for a device
        async function updateTemperatureControl(deviceId) {
            console.log(`Setting up temperature control for device ${deviceId}`);
            
            // Clear any existing interval
            if (tempControlIntervals[deviceId]) {
                clearInterval(tempControlIntervals[deviceId]);
                console.log(`Cleared existing temperature control interval for device ${deviceId}`);
            }
            
            const statusDiv = document.getElementById(`temp-status-${deviceId}`);
            statusDiv.textContent = 'Initializing temperature control...';
            
            const sourceRadio = document.querySelector(`input[name="temp-source-${deviceId}"]:checked`);
            const minTempInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-temp-min"]`);
            const maxTempInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-temp-max"]`);
            const functionSelect = document.querySelector(`[data-device="${deviceId}"][data-control="temp-function"]`);
            
            if (!minTempInput || !maxTempInput || !functionSelect) {
                statusDiv.textContent = 'Error: Could not find control elements';
                console.error(`Missing control elements for device ${deviceId}`);
                return;
            }
            
            const source = sourceRadio ? sourceRadio.value : 'inside';
            const minTemp = parseFloat(minTempInput.value);
            const maxTemp = parseFloat(maxTempInput.value);
            const tempFunction = functionSelect.value; // 'outside' or 'inside' range
            
            console.log(`Temperature control configured: source=${source}, min=${minTemp}, max=${maxTemp}, function=${tempFunction}`);
            
            // Update status message
            statusDiv.textContent = `Controlling based on ${source} temperature. Range: ${minTemp}°F - ${maxTemp}°F, Function: ${tempFunction === 'outside' ? 'Turn on when outside range' : 'Turn on when inside range'}`;
            
            // Outside temperature data warning
            if (source === 'outside') {
                statusDiv.textContent += ' (Outside temperature data may not be available)';
            }
            
            // Set up interval to check temperature and control device
            tempControlIntervals[deviceId] = setInterval(async () => {
                // Get current temperature data
                const tempData = await getCurrentTemperatureData();
                if (!tempData) {
                    statusDiv.textContent = 'Unable to fetch temperature data. Using default of 0°F.';
                    return;
                }
                
                // Use outdoor or indoor temperature based on the source setting
                // Default to 0 if unavailable instead of showing error
                let currentTemp = 0;
                let sensorStatus = "available";
                
                if (source === 'outside') {
                    currentTemp = tempData.outdoorTemperature;
                    if (currentTemp === 0 && document.getElementById('outdoor-temp').textContent === "N/A") {
                        sensorStatus = "unavailable";
                    }
                } else {
                    currentTemp = tempData.temperature_f; // Use Fahrenheit value
                    if (currentTemp === 0 && document.getElementById('indoor-temp').textContent === "N/A") {
                        sensorStatus = "unavailable";
                    }
                }
                
                // Determine if device should be on or off based on range
                let shouldBeOn = false;
                if (tempFunction === 'outside') {
                    // Turn ON when outside range (below min or above max)
                    shouldBeOn = currentTemp < minTemp || currentTemp > maxTemp;
                } else {
                    // Turn ON when inside range (between min and max)
                    shouldBeOn = currentTemp >= minTemp && currentTemp <= maxTemp;
                }
                
                // Get current device status - use cache when possible
                const cachedStatus = window.deviceStatusCache[deviceId];
                let deviceStatus = false;
                
                if (cachedStatus && (new Date().getTime() - cachedStatus.timestamp < 300000)) {
                    // Use cached status if it's less than 5 minutes old
                    deviceStatus = cachedStatus.power;
                } else {
                    // Get status from UI if cache is old or unavailable
                    const deviceStatusEl = document.getElementById(`device-status-${deviceId}`);
                    deviceStatus = deviceStatusEl?.textContent?.includes('ON') || false;
                }
                
                // Update status message with more detailed explanation
                const sourceLabel = source === 'outside' ? 'Outdoor' : 'Indoor';
                let statusMessage = '';
                
                if (sensorStatus === "unavailable") {
                    statusMessage = `${sourceLabel} sensor unavailable. Using default of 0°F. `;
                } else {
                    statusMessage = `Current ${sourceLabel}: ${currentTemp.toFixed(1)}°F. `;
                }
                
                // Add range information
                statusMessage += `Range: ${minTemp}°F - ${maxTemp}°F. `;
                
                // Add explanation of why it should be on or off
                if (tempFunction === 'outside') {
                    if (shouldBeOn) {
                        if (currentTemp < minTemp) {
                            statusMessage += `Should be ON (temperature ${currentTemp.toFixed(1)}°F is below min ${minTemp}°F). `;
                        } else {
                            statusMessage += `Should be ON (temperature ${currentTemp.toFixed(1)}°F is above max ${maxTemp}°F). `;
                        }
                    } else {
                        statusMessage += `Should be OFF (temperature ${currentTemp.toFixed(1)}°F is within range). `;
                    }
                } else { // inside range
                    if (shouldBeOn) {
                        statusMessage += `Should be ON (temperature ${currentTemp.toFixed(1)}°F is within range). `;
                    } else {
                        if (currentTemp < minTemp) {
                            statusMessage += `Should be OFF (temperature ${currentTemp.toFixed(1)}°F is below min ${minTemp}°F). `;
                        } else {
                            statusMessage += `Should be OFF (temperature ${currentTemp.toFixed(1)}°F is above max ${maxTemp}°F). `;
                        }
                    }
                }
                
                // Add current status
                statusMessage += `Currently: ${deviceStatus ? 'ON' : 'OFF'}`;
                statusDiv.textContent = statusMessage;
                
                // Control device if state needs to change
                if (deviceStatus !== shouldBeOn) {
                    console.log(`Temperature control: Changing device ${deviceId} state to ${shouldBeOn ? 'ON' : 'OFF'}`);
                    if (shouldBeOn) {
                        await controlDevice(deviceId, 'on');
                    } else {
                        await controlDevice(deviceId, 'off');
                    }
                }
            }, 300000); // Check every 5 minutes
            
            // Run once immediately
            const tempData = await getCurrentTemperatureData();
            if (tempData) {
                // Use 0 as default value for missing data
                let currentTemp = 0;
                let sensorStatus = "available";
                
                if (source === 'outside') {
                    currentTemp = tempData.outdoorTemperature || 0;
                    if (currentTemp === 0 && document.getElementById('outdoor-temp').textContent === "N/A") {
                        sensorStatus = "unavailable";
                    }
                } else {
                    currentTemp = tempData.temperature_f || 0;
                    if (currentTemp === 0 && document.getElementById('indoor-temp').textContent === "N/A") {
                        sensorStatus = "unavailable";
                    }
                }
                
                // Determine if device should be on or off based on range
                let shouldBeOn = false;
                if (tempFunction === 'outside') {
                    // Turn ON when outside range (below min or above max)
                    shouldBeOn = currentTemp < minTemp || currentTemp > maxTemp;
                } else {
                    // Turn ON when inside range (between min and max)
                    shouldBeOn = currentTemp >= minTemp && currentTemp <= maxTemp;
                }
                
                // Create detailed status message
                let statusMessage = '';
                const sourceLabel = source === 'outside' ? 'Outdoor' : 'Indoor';
                
                if (sensorStatus === "unavailable") {
                    statusMessage = `${sourceLabel} sensor unavailable. Using default of 0°F. `;
                } else {
                    statusMessage = `Current ${sourceLabel}: ${currentTemp.toFixed(1)}°F. `;
                }
                
                // Add range information
                statusMessage += `Range: ${minTemp}°F - ${maxTemp}°F. `;
                
                // Add explanation of why it should be on or off
                if (tempFunction === 'outside') {
                    if (shouldBeOn) {
                        if (currentTemp < minTemp) {
                            statusMessage += `Should be ON (temperature ${currentTemp.toFixed(1)}°F is below min ${minTemp}°F).`;
                        } else {
                            statusMessage += `Should be ON (temperature ${currentTemp.toFixed(1)}°F is above max ${maxTemp}°F).`;
                        }
                    } else {
                        statusMessage += `Should be OFF (temperature ${currentTemp.toFixed(1)}°F is within range).`;
                    }
                } else { // inside range
                    if (shouldBeOn) {
                        statusMessage += `Should be ON (temperature ${currentTemp.toFixed(1)}°F is within range).`;
                    } else {
                        if (currentTemp < minTemp) {
                            statusMessage += `Should be OFF (temperature ${currentTemp.toFixed(1)}°F is below min ${minTemp}°F).`;
                        } else {
                            statusMessage += `Should be OFF (temperature ${currentTemp.toFixed(1)}°F is above max ${maxTemp}°F).`;
                        }
                    }
                }
                
                statusDiv.textContent = statusMessage;
                
                // Set initial state
                const deviceStatusEl = document.getElementById(`device-status-${deviceId}`);
                const deviceStatus = deviceStatusEl?.textContent?.includes('ON') || false;
                
                if (deviceStatus !== shouldBeOn) {
                    if (shouldBeOn) {
                        await controlDevice(deviceId, 'on');
                    } else {
                        await controlDevice(deviceId, 'off');
                    }
                }
            } else {
                statusDiv.textContent = 'Unable to fetch temperature data. Using default of 0°F.';
            }
        }
        
        // Stop temperature control for a device
        function stopTemperatureControl(deviceId) {
            if (tempControlIntervals[deviceId]) {
                console.log(`Stopping temperature control for device ${deviceId}`);
                clearInterval(tempControlIntervals[deviceId]);
                delete tempControlIntervals[deviceId];
            }
        }
        
        // Update humidity control for a device
        async function updateHumidityControl(deviceId) {
            console.log(`Setting up humidity control for device ${deviceId}`);
            
            // Clear any existing interval
            if (humidityControlIntervals[deviceId]) {
                clearInterval(humidityControlIntervals[deviceId]);
                console.log(`Cleared existing humidity control interval for device ${deviceId}`);
            }
            
            const statusDiv = document.getElementById(`humidity-status-${deviceId}`);
            statusDiv.textContent = 'Initializing humidity control...';
            
            const sourceRadio = document.querySelector(`input[name="humidity-source-${deviceId}"]:checked`);
            const minHumidityInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-humidity-min"]`);
            const maxHumidityInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-humidity-max"]`);
            const functionSelect = document.querySelector(`[data-device="${deviceId}"][data-control="humidity-function"]`);
            
            if (!minHumidityInput || !maxHumidityInput || !functionSelect) {
                statusDiv.textContent = 'Error: Could not find control elements';
                console.error(`Missing humidity control elements for device ${deviceId}`);
                return;
            }
            
            const source = sourceRadio ? sourceRadio.value : 'inside';
            const minHumidity = parseFloat(minHumidityInput.value);
            const maxHumidity = parseFloat(maxHumidityInput.value);
            const humidityFunction = functionSelect.value; // 'outside' or 'inside' range
            
            console.log(`Humidity control configured: source=${source}, min=${minHumidity}, max=${maxHumidity}, function=${humidityFunction}`);
            
            // Update status message
            statusDiv.textContent = `Controlling based on ${source} humidity. Range: ${minHumidity}% - ${maxHumidity}%, Function: ${humidityFunction === 'outside' ? 'Turn on when outside range' : 'Turn on when inside range'}`;
            
            // Outside humidity data warning
            if (source === 'outside') {
                statusDiv.textContent += ' (Outside humidity data may not be available)';
            }
            
            // Set up interval to check humidity and control device
            humidityControlIntervals[deviceId] = setInterval(async () => {
                // Get current humidity data
                const humidityData = await getCurrentTemperatureData();
                if (!humidityData) {
                    statusDiv.textContent = 'Unable to fetch humidity data. Using default of 0%.';
                    return;
                }
                
                // Use outdoor or indoor humidity based on the source setting
                // Default to 0 if unavailable
                let currentHumidity = 0;
                let sensorStatus = "available";
                
                if (source === 'outside') {
                    currentHumidity = humidityData.outdoorHumidity || 0;
                    if (currentHumidity === 0 && document.getElementById('outdoor-humidity').textContent === "N/A") {
                        sensorStatus = "unavailable";
                    }
                } else {
                    currentHumidity = humidityData.humidity || 0;
                    if (currentHumidity === 0 && document.getElementById('indoor-temp').textContent === "N/A") {
                        sensorStatus = "unavailable";
                    }
                }
                
                // Determine if device should be on or off based on range
                let shouldBeOn = false;
                if (humidityFunction === 'outside') {
                    // Turn ON when outside range (below min or above max)
                    shouldBeOn = currentHumidity < minHumidity || currentHumidity > maxHumidity;
                } else {
                    // Turn ON when inside range (between min and max)
                    shouldBeOn = currentHumidity >= minHumidity && currentHumidity <= maxHumidity;
                }
                
                // Get current device status - use cache when possible
                const cachedStatus = window.deviceStatusCache[deviceId];
                let deviceStatus = false;
                
                if (cachedStatus && (new Date().getTime() - cachedStatus.timestamp < 300000)) {
                    // Use cached status if it's less than 5 minutes old
                    deviceStatus = cachedStatus.power;
                } else {
                    // Get status from UI if cache is old or unavailable
                    const deviceStatusEl = document.getElementById(`device-status-${deviceId}`);
                    deviceStatus = deviceStatusEl?.textContent?.includes('ON') || false;
                }
                
                // Create detailed status message
                let statusMessage = '';
                const sourceLabel = source === 'outside' ? 'Outdoor' : 'Indoor';
                
                if (sensorStatus === "unavailable") {
                    statusMessage = `${sourceLabel} sensor unavailable. Using default of 0%. `;
                } else {
                    statusMessage = `Current ${sourceLabel}: ${currentHumidity}%. `;
                }
                
                // Add range information
                statusMessage += `Range: ${minHumidity}% - ${maxHumidity}%. `;
                
                // Add explanation of why it should be on or off
                if (humidityFunction === 'outside') {
                    if (shouldBeOn) {
                        if (currentHumidity < minHumidity) {
                            statusMessage += `Should be ON (humidity ${currentHumidity}% is below min ${minHumidity}%). `;
                        } else {
                            statusMessage += `Should be ON (humidity ${currentHumidity}% is above max ${maxHumidity}%). `;
                        }
                    } else {
                        statusMessage += `Should be OFF (humidity ${currentHumidity}% is within range). `;
                    }
                } else { // inside range
                    if (shouldBeOn) {
                        statusMessage += `Should be ON (humidity ${currentHumidity}% is within range). `;
                    } else {
                        if (currentHumidity < minHumidity) {
                            statusMessage += `Should be OFF (humidity ${currentHumidity}% is below min ${minHumidity}%). `;
                        } else {
                            statusMessage += `Should be OFF (humidity ${currentHumidity}% is above max ${maxHumidity}%). `;
                        }
                    }
                }
                
                // Add current status
                statusMessage += `Currently: ${deviceStatus ? 'ON' : 'OFF'}`;
                statusDiv.textContent = statusMessage;
                
                // Control device if state needs to change
                if (deviceStatus !== shouldBeOn) {
                    console.log(`Humidity control: Changing device ${deviceId} state to ${shouldBeOn ? 'ON' : 'OFF'}`);
                    if (shouldBeOn) {
                        await controlDevice(deviceId, 'on');
                    } else {
                        await controlDevice(deviceId, 'off');
                    }
                }
            }, 300000); // Check every 5 minutes
            
            // Run once immediately
            const humidityData = await getCurrentTemperatureData();
            if (humidityData) {
                // Use 0 as default for missing data
                let currentHumidity = 0;
                let sensorStatus = "available";
                
                if (source === 'outside') {
                    currentHumidity = humidityData.outdoorHumidity || 0;
                    if (currentHumidity === 0 && document.getElementById('outdoor-humidity').textContent === "N/A") {
                        sensorStatus = "unavailable";
                    }
                } else {
                    currentHumidity = humidityData.humidity || 0;
                    if (currentHumidity === 0 && document.getElementById('indoor-temp').textContent === "N/A") {
                        sensorStatus = "unavailable";
                    }
                }
                
                // Determine if device should be on or off based on range
                let shouldBeOn = false;
                if (humidityFunction === 'outside') {
                    // Turn ON when outside range (below min or above max)
                    shouldBeOn = currentHumidity < minHumidity || currentHumidity > maxHumidity;
                } else {
                    // Turn ON when inside range (between min and max)
                    shouldBeOn = currentHumidity >= minHumidity && currentHumidity <= maxHumidity;
                }
                
                // Create detailed status message
                let statusMessage = '';
                const sourceLabel = source === 'outside' ? 'Outdoor' : 'Indoor';
                
                if (sensorStatus === "unavailable") {
                    statusMessage = `${sourceLabel} sensor unavailable. Using default of 0%. `;
                } else {
                    statusMessage = `Current ${sourceLabel}: ${currentHumidity}%. `;
                }
                
                // Add range information
                statusMessage += `Range: ${minHumidity}% - ${maxHumidity}%. `;
                
                // Add explanation of why it should be on or off
                if (humidityFunction === 'outside') {
                    if (shouldBeOn) {
                        if (currentHumidity < minHumidity) {
                            statusMessage += `Should be ON (humidity ${currentHumidity}% is below min ${minHumidity}%).`;
                        } else {
                            statusMessage += `Should be ON (humidity ${currentHumidity}% is above max ${maxHumidity}%).`;
                        }
                    } else {
                        statusMessage += `Should be OFF (humidity ${currentHumidity}% is within range).`;
                    }
                } else { // inside range
                    if (shouldBeOn) {
                        statusMessage += `Should be ON (humidity ${currentHumidity}% is within range).`;
                    } else {
                        if (currentHumidity < minHumidity) {
                            statusMessage += `Should be OFF (humidity ${currentHumidity}% is below min ${minHumidity}%).`;
                        } else {
                            statusMessage += `Should be OFF (humidity ${currentHumidity}% is above max ${maxHumidity}%).`;
                        }
                    }
                }
                
                statusDiv.textContent = statusMessage;
                
                // Set initial state
                const deviceStatusEl = document.getElementById(`device-status-${deviceId}`);
                const deviceStatus = deviceStatusEl?.textContent?.includes('ON') || false;
                
                if (deviceStatus !== shouldBeOn) {
                    if (shouldBeOn) {
                        await controlDevice(deviceId, 'on');
                    } else {
                        await controlDevice(deviceId, 'off');
                    }
                }
            } else {
                statusDiv.textContent = 'Unable to fetch humidity data. Using default of 0%.';
            }
        }
        
        // Stop humidity control for a device
        function stopHumidityControl(deviceId) {
            if (humidityControlIntervals[deviceId]) {
                console.log(`Stopping humidity control for device ${deviceId}`);
                clearInterval(humidityControlIntervals[deviceId]);
                delete humidityControlIntervals[deviceId];
            }
        }

        // Function to save device settings
        async function saveDeviceSettings(deviceId) {
            try {
                // Show saving indicator
                const tempStatusDiv = document.getElementById(`temp-settings-status-${deviceId}`);
                const humidityStatusDiv = document.getElementById(`humidity-settings-status-${deviceId}`);
                
                if (tempStatusDiv) tempStatusDiv.innerHTML = '<span class="text-blue-500">Saving to server...</span>';
                if (humidityStatusDiv) humidityStatusDiv.innerHTML = '<span class="text-purple-500">Saving to server...</span>';
                
                // Get temperature settings
                const tempToggle = document.getElementById(`temp-toggle-${deviceId}`);
                const tempSourceRadio = document.querySelector(`input[name="temp-source-${deviceId}"]:checked`);
                const minTempInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-temp-min"]`);
                const maxTempInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-temp-max"]`);
                const tempFunctionSelect = document.querySelector(`[data-device="${deviceId}"][data-control="temp-function"]`);
                
                // Get humidity settings
                const humidityToggle = document.getElementById(`humidity-toggle-${deviceId}`);
                const humiditySourceRadio = document.querySelector(`input[name="humidity-source-${deviceId}"]:checked`);
                const minHumidityInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-humidity-min"]`);
                const maxHumidityInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-humidity-max"]`);
                const humidityFunctionSelect = document.querySelector(`[data-device="${deviceId}"][data-control="humidity-function"]`);
                
                // Get the values we need
                const enabled_temp = tempToggle ? tempToggle.checked : false;
                const source_temp = tempSourceRadio ? tempSourceRadio.value : 'inside';
                const min_temp = minTempInput ? parseFloat(minTempInput.value) : 50.0;
                const max_temp = maxTempInput ? parseFloat(maxTempInput.value) : 80.0;
                const temp_range_type = tempFunctionSelect ? tempFunctionSelect.value : 'outside';
                
                const enabled_humidity = humidityToggle ? humidityToggle.checked : false;
                const source_humidity = humiditySourceRadio ? humiditySourceRadio.value : 'inside';
                const min_humidity = minHumidityInput ? parseFloat(minHumidityInput.value) : 40.0;
                const max_humidity = maxHumidityInput ? parseFloat(maxHumidityInput.value) : 60.0;
                const humidity_range_type = humidityFunctionSelect ? humidityFunctionSelect.value : 'outside';
                
                // For temperature - convert our inside/outside range logic to above/below for server
                let temp_function;
                let target_temp;
                
                if (temp_range_type === 'outside') {
                    // "Turn ON when outside range X-Y" -> "Turn ON when below X or above Y"
                    temp_function = 'below';
                    target_temp = min_temp;
                } else {
                    // "Turn ON when inside range X-Y" -> "Turn ON when above X and below Y"
                    temp_function = 'above';
                    target_temp = min_temp;
                }
                
                // For humidity - convert our inside/outside range logic to above/below for server
                let humidity_function;
                let target_humidity;
                
                if (humidity_range_type === 'outside') {
                    // "Turn ON when outside range X-Y" -> "Turn ON when below X or above Y"
                    humidity_function = 'below';
                    target_humidity = min_humidity;
                } else {
                    // "Turn ON when inside range X-Y" -> "Turn ON when above X and below Y"
                    humidity_function = 'above';
                    target_humidity = min_humidity;
                }

                // Convert Fahrenheit to Celsius for server storage 
                // The database expects temperatures in Celsius but the UI works in Fahrenheit
                const target_temp_celsius = ((target_temp - 32) * 5) / 9;
                const target_temp_max_celsius = ((max_temp - 32) * 5) / 9; // Convert max_temp to Celsius
                
                // Create a settings object that exactly matches the server model fields
                const settings = {
                    device_id: deviceId,
                    // Temperature settings
                    temp_control_enabled: enabled_temp,
                    temp_source: source_temp,
                    target_temp: target_temp_celsius, // Store in Celsius in database
                    target_temp_max_celsius: target_temp_max_celsius, // Store max in Celsius
                    temp_function: temp_function,
                    // Humidity settings
                    humidity_control_enabled: enabled_humidity,
                    humidity_source: source_humidity,
                    target_humidity: target_humidity, // Min humidity
                    target_humidity_max: max_humidity, // Max humidity (already % so no conversion needed for unit, just ensure field name matches server)
                    humidity_function: humidity_function,
                    // Add simple timestamp for tracking
                    last_updated: new Date().toISOString()
                };
                
                console.log('Saving device settings to server:', settings);
                
                // Save to the server
                try {
                    // Get the CSRF token
                    const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;
                    
                    // Check for network connectivity
                    if (!navigator.onLine) {
                        throw new Error('No internet connection. Cannot save settings.');
                    }
                    
                    // Use FormData for better compatibility
                    const formData = new FormData();
                    formData.append('data', JSON.stringify(settings));
                    
                    console.log('Sending request to /save_device_settings/');
                    const controller = new AbortController(); // For timeout handling
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                    
                    const response = await fetch('/save_device_settings/', {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': csrftoken,
                            'Cache-Control': 'no-cache'
                        },
                        body: formData,
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        throw new Error(`Server returned status ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        console.log('Settings saved successfully to server');
                        
                        // Also save the complete UI settings (with min/max values) to localStorage as a backup
                        const uiSettings = {
                            ...settings, // settings already contains target_temp_celsius and target_temp_max_celsius
                            // Add UI-specific fields that aren't in the server model, ensure they are in Fahrenheit for UI
                            target_temp_min: min_temp, // Fahrenheit min from UI
                            target_temp_max: max_temp, // Fahrenheit max from UI
                            temp_range_type: temp_range_type,
                            target_humidity_min: min_humidity, // % min from UI
                            target_humidity_max: max_humidity, // % max from UI
                            humidity_range_type: humidity_range_type,
                            last_saved: new Date().toISOString()
                        };
                        
                        try {
                            localStorage.setItem(`device_settings_${deviceId}`, JSON.stringify(uiSettings));
                        } catch (e) {
                            console.warn('Could not save to local storage:', e);
                        }
                        
                        // Show success message
                        if (tempStatusDiv) {
                            tempStatusDiv.innerHTML = '<span class="text-green-500">Settings saved ✓</span>';
                            setTimeout(() => {
                                tempStatusDiv.innerHTML = '';
                            }, 3000);
                        }
                        
                        if (humidityStatusDiv) {
                            humidityStatusDiv.innerHTML = '<span class="text-green-500">Settings saved ✓</span>';
                            setTimeout(() => {
                                humidityStatusDiv.innerHTML = '';
                            }, 3000);
                        }
                        
                        // Update the UI state if needed
                        updateManualButtons(deviceId);
                        
                        if (enabled_temp) {
                            updateTemperatureControl(deviceId);
                        } else {
                            stopTemperatureControl(deviceId);
                        }
                        
                        if (enabled_humidity) {
                            updateHumidityControl(deviceId);
                        } else {
                            stopHumidityControl(deviceId);
                        }
                        
                    } else {
                        console.error('Error saving settings:', data.error);
                        throw new Error(data.error || 'Server error');
                    }
                } catch (error) {
                    console.error('Error saving device settings to server:', error);
                    // Show error message
                    if (tempStatusDiv) {
                        tempStatusDiv.innerHTML = `<span class="text-red-500">Error: ${error.message}</span>`;
                        setTimeout(() => {
                            tempStatusDiv.innerHTML = '';
                        }, 5000);
                    }
                    
                    if (humidityStatusDiv) {
                        humidityStatusDiv.innerHTML = `<span class="text-red-500">Error: ${error.message}</span>`;
                        setTimeout(() => {
                            humidityStatusDiv.innerHTML = '';
                        }, 5000);
                    }
                    
                    // Also show global error message
                    showStatusMessage(`Error saving settings: ${error.message}`, 'error');
                }
            } catch (error) {
                console.error('General error in saveDeviceSettings:', error);
                // Show error message
                const tempStatusDiv = document.getElementById(`temp-settings-status-${deviceId}`);
                const humidityStatusDiv = document.getElementById(`humidity-settings-status-${deviceId}`);
                
                if (tempStatusDiv) tempStatusDiv.innerHTML = '<span class="text-red-500">Error: ' + error.message + '</span>';
                if (humidityStatusDiv) humidityStatusDiv.innerHTML = '<span class="text-red-500">Error: ' + error.message + '</span>';
            }
        }

        // Helper function to recover settings from local storage
        function tryRecoverSettings(deviceId) {
            try {
                const storageKey = `device_settings_${deviceId}`;
                const savedSettings = localStorage.getItem(storageKey);
                if (savedSettings) {
                    console.log('Attempting to recover settings from local storage');
                    const settings = JSON.parse(savedSettings);
                    
                    // Apply recovered settings
                    const tempToggle = document.getElementById(`temp-toggle-${deviceId}`);
                    if (tempToggle) {
                        tempToggle.checked = settings.temp_control_enabled;
                        // Show/hide controls
                        const tempControlsDiv = document.getElementById(`temp-controls-${deviceId}`);
                        if (tempControlsDiv) {
                            tempControlsDiv.classList.toggle('hidden', !settings.temp_control_enabled);
                        }
                    }
                    
                    // Apply source selection
                    const tempSources = document.querySelectorAll(`input[name="temp-source-${deviceId}"]`);
                    tempSources.forEach(radio => {
                        if (radio.value === settings.temp_source) {
                            radio.checked = true;
                        }
                    });
                    
                    // Apply min/max temperature
                    const minTempInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-temp-min"]`);
                    const maxTempInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-temp-max"]`);
                    if (minTempInput && settings.target_temp_min !== undefined) {
                        minTempInput.value = settings.target_temp_min;
                        // Also update the displayed value
                        const minTempDisplay = document.getElementById(`temp-min-value-${deviceId}`);
                        if (minTempDisplay) {
                            minTempDisplay.textContent = Math.round(settings.target_temp_min);
                        }
                    }
                    if (maxTempInput && settings.target_temp_max !== undefined) {
                        maxTempInput.value = settings.target_temp_max;
                        // Also update the displayed value
                        const maxTempDisplay = document.getElementById(`temp-max-value-${deviceId}`);
                        if (maxTempDisplay) {
                            maxTempDisplay.textContent = Math.round(settings.target_temp_max);
                        }
                    }
                    
                    // Apply temperature function
                    const tempFunctionSelect = document.querySelector(`[data-device="${deviceId}"][data-control="temp-function"]`);
                    if (tempFunctionSelect && settings.temp_range_type) {
                        tempFunctionSelect.value = settings.temp_range_type;
                    }
                    
                    // Handle humidity controls similarly
                    const humidityToggle = document.getElementById(`humidity-toggle-${deviceId}`);
                    if (humidityToggle) {
                        humidityToggle.checked = settings.humidity_control_enabled;
                        // Show/hide controls based on toggle state
                        const humidityControlsDiv = document.getElementById(`humidity-controls-${deviceId}`);
                        if (humidityControlsDiv) {
                            humidityControlsDiv.classList.toggle('hidden', !settings.humidity_control_enabled);
                        }
                    }
                    
                    // Apply humidity source selection
                    const humiditySources = document.querySelectorAll(`input[name="humidity-source-${deviceId}"]`);
                    humiditySources.forEach(radio => {
                        if (radio.value === settings.humidity_source) {
                            radio.checked = true;
                        }
                    });
                    
                    // Apply min/max humidity
                    const minHumidityInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-humidity-min"]`);
                    const maxHumidityInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-humidity-max"]`);
                    if (minHumidityInput && settings.target_humidity_min !== undefined) {
                        minHumidityInput.value = settings.target_humidity_min;
                        // Also update the displayed value
                        const minHumidityDisplay = document.getElementById(`humidity-min-value-${deviceId}`);
                        if (minHumidityDisplay) {
                            minHumidityDisplay.textContent = Math.round(settings.target_humidity_min);
                        }
                    }
                    if (maxHumidityInput && settings.target_humidity_max !== undefined) {
                        maxHumidityInput.value = settings.target_humidity_max;
                        // Also update the displayed value
                        const maxHumidityDisplay = document.getElementById(`humidity-max-value-${deviceId}`);
                        if (maxHumidityDisplay) {
                            maxHumidityDisplay.textContent = Math.round(settings.target_humidity_max);
                        }
                    }
                    
                    // Apply humidity function
                    const humidityFunctionSelect = document.querySelector(`[data-device="${deviceId}"][data-control="humidity-function"]`);
                    if (humidityFunctionSelect && settings.humidity_range_type) {
                        humidityFunctionSelect.value = settings.humidity_range_type;
                    }
                    
                    console.log('Successfully recovered and applied settings from local storage');
                    
                    // Update the status labels
                    const tempStatusDiv = document.getElementById(`temp-settings-status-${deviceId}`);
                    const humidityStatusDiv = document.getElementById(`humidity-settings-status-${deviceId}`);
                    
                    if (tempStatusDiv) {
                        tempStatusDiv.innerHTML = '<span class="text-yellow-500">Using offline settings (not synced with server)</span>';
                    }
                    if (humidityStatusDiv) {
                        humidityStatusDiv.innerHTML = '<span class="text-yellow-500">Using offline settings (not synced with server)</span>';
                    }
                    
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Error recovering settings from local storage:', error);
                return false;
            }
        }

        // Function to load device settings
        async function loadDeviceSettings(deviceId, forceRefresh = false) {
            try {
                // Show loading indicator
                const tempStatusDiv = document.getElementById(`temp-settings-status-${deviceId}`);
                const humidityStatusDiv = document.getElementById(`humidity-settings-status-${deviceId}`);
                
                if (tempStatusDiv) tempStatusDiv.innerHTML = '<span class="text-blue-500">Loading from server...</span>';
                if (humidityStatusDiv) humidityStatusDiv.innerHTML = '<span class="text-purple-500">Loading from server...</span>';
                
                console.log(`Loading settings for device ${deviceId}`);
                
                // Generate a client ID for this request
                const clientId = generateClientId();
                
                // Add a timestamp to prevent caching
                const timestamp = new Date().getTime();
                const randomVal = Math.floor(Math.random() * 1000000); // Add more randomness
                const url = `/get_device_settings/?device_id=${deviceId}&force_refresh=${forceRefresh}&_=${timestamp}&r=${randomVal}`;
                
                // Add a timeout for the request
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout
                
                try {
                    const response = await fetch(url, {
                        signal: controller.signal,
                        headers: {
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache',
                            'Expires': '0'
                        }
                    });
                    
                    clearTimeout(timeoutId); // Clear timeout if request completes
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    console.log(`Settings data for ${deviceId}:`, data);
                    
                    if (data.success) {
                        const serverSettings = data.settings;
                        console.log(`Successfully loaded server settings for ${deviceId}:`, serverSettings);
                        
                        // Convert function to range type (above/below -> inside/outside)
                        const temp_range_type = serverSettings.temp_function === 'below' ? 'outside' : 'inside';
                        const humidity_range_type = serverSettings.humidity_function === 'below' ? 'outside' : 'inside';
                        
                        // Convert server Celsius min and max to Fahrenheit for UI
                        const target_temp_f_min = serverSettings.target_temp * (9/5) + 32;
                        const target_temp_f_max = serverSettings.target_temp_max_celsius * (9/5) + 32;

                        // Humidity min and max are already in %
                        const target_humidity_min = serverSettings.target_humidity;
                        const target_humidity_max = serverSettings.target_humidity_max;
                                                
                        // Create UI settings object using server settings as the base
                        const uiSettings = {
                            ...serverSettings, // Includes Celsius temps from server
                            // Add/overwrite with UI-specific fields in Fahrenheit or correct units
                            target_temp_min: target_temp_f_min,      // Fahrenheit min
                            target_temp_max: target_temp_f_max,      // Fahrenheit max
                            temp_range_type: temp_range_type,
                            target_humidity_min: target_humidity_min,  // Already %
                            target_humidity_max: target_humidity_max,  // Already %
                            humidity_range_type: humidity_range_type,
                            last_fetched: new Date().toISOString(),
                            server_synced: true,
                            client_id: clientId
                        };
                        
                        console.log('Created UI settings from server settings:', uiSettings);
                        
                        // Save to localStorage for offline use
                        try {
                            const storageKey = `device_settings_${deviceId}`;
                            localStorage.setItem(storageKey, JSON.stringify(uiSettings));
                            console.log('Saved server-synchronized UI settings to localStorage');
                        } catch (storageError) {
                            console.warn('Could not save to local storage:', storageError);
                        }
                        
                        // Apply settings to UI controls
                        
                        // Apply temperature settings
                        const tempToggle = document.getElementById(`temp-toggle-${deviceId}`);
                        if (tempToggle) {
                            console.log(`Setting temperature toggle for ${deviceId} to:`, uiSettings.temp_control_enabled);
                            tempToggle.checked = uiSettings.temp_control_enabled;
                            
                            // Show/hide controls based on toggle state
                            const tempControlsDiv = document.getElementById(`temp-controls-${deviceId}`);
                            if (tempControlsDiv) {
                                if (uiSettings.temp_control_enabled) {
                                    tempControlsDiv.classList.remove('hidden');
                                } else {
                                    tempControlsDiv.classList.add('hidden');
                                }
                            }
                        }
                        
                        // Set temperature source
                        const tempSourceRadio = document.querySelector(`input[name="temp-source-${deviceId}"][value="${uiSettings.temp_source}"]`);
                        if (tempSourceRadio) {
                            tempSourceRadio.checked = true;
                        }
                        
                        // Set min temperature
                        const minTempInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-temp-min"]`);
                        if (minTempInput) {
                            minTempInput.value = uiSettings.target_temp_min;
                            // Also update the displayed value
                            const minTempDisplay = document.getElementById(`temp-min-value-${deviceId}`);
                            if (minTempDisplay) {
                                minTempDisplay.textContent = Math.round(uiSettings.target_temp_min);
                            }
                        }
                        
                        // Set max temperature
                        const maxTempInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-temp-max"]`);
                        if (maxTempInput) {
                            maxTempInput.value = uiSettings.target_temp_max;
                            // Also update the displayed value
                            const maxTempDisplay = document.getElementById(`temp-max-value-${deviceId}`);
                            if (maxTempDisplay) {
                                maxTempDisplay.textContent = Math.round(uiSettings.target_temp_max);
                            }
                        }
                        
                        // Set temperature function
                        const tempFunctionSelect = document.querySelector(`[data-device="${deviceId}"][data-control="temp-function"]`);
                        if (tempFunctionSelect) {
                            tempFunctionSelect.value = uiSettings.temp_range_type;
                        }
                        
                        // Apply humidity settings
                        const humidityToggle = document.getElementById(`humidity-toggle-${deviceId}`);
                        if (humidityToggle) {
                            console.log(`Setting humidity toggle for ${deviceId} to:`, uiSettings.humidity_control_enabled);
                            humidityToggle.checked = uiSettings.humidity_control_enabled;
                            
                            // Show/hide controls based on toggle state
                            const humidityControlsDiv = document.getElementById(`humidity-controls-${deviceId}`);
                            if (humidityControlsDiv) {
                                if (uiSettings.humidity_control_enabled) {
                                    humidityControlsDiv.classList.remove('hidden');
                                } else {
                                    humidityControlsDiv.classList.add('hidden');
                                }
                            }
                        }
                        
                        // Set humidity source
                        const humiditySourceRadio = document.querySelector(`input[name="humidity-source-${deviceId}"][value="${uiSettings.humidity_source}"]`);
                        if (humiditySourceRadio) {
                            humiditySourceRadio.checked = true;
                        }
                        
                        // Set min humidity
                        const minHumidityInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-humidity-min"]`);
                        if (minHumidityInput) {
                            minHumidityInput.value = uiSettings.target_humidity_min;
                            // Also update the displayed value
                            const minHumidityDisplay = document.getElementById(`humidity-min-value-${deviceId}`);
                            if (minHumidityDisplay) {
                                minHumidityDisplay.textContent = Math.round(uiSettings.target_humidity_min);
                            }
                        }
                        
                        // Set max humidity
                        const maxHumidityInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-humidity-max"]`);
                        if (maxHumidityInput) {
                            maxHumidityInput.value = uiSettings.target_humidity_max;
                            // Also update the displayed value
                            const maxHumidityDisplay = document.getElementById(`humidity-max-value-${deviceId}`);
                            if (maxHumidityDisplay) {
                                maxHumidityDisplay.textContent = Math.round(uiSettings.target_humidity_max);
                            }
                        }
                        
                        // Set humidity function
                        const humidityFunctionSelect = document.querySelector(`[data-device="${deviceId}"][data-control="humidity-function"]`);
                        if (humidityFunctionSelect) {
                            humidityFunctionSelect.value = uiSettings.humidity_range_type;
                        }
                        
                        // Update manual button states
                        updateManualButtons(deviceId);
                        
                        // Initialize controls if enabled
                        if (uiSettings.temp_control_enabled) {
                            setTimeout(() => updateTemperatureControl(deviceId), 500);
                        }
                        
                        if (uiSettings.humidity_control_enabled) {
                            setTimeout(() => updateHumidityControl(deviceId), 1000);
                        }
                        
                        // Show success message
                        if (tempStatusDiv) {
                            tempStatusDiv.innerHTML = '<span class="text-green-500">Settings loaded ✓</span>';
                            setTimeout(() => {
                                tempStatusDiv.innerHTML = '';
                            }, 3000);
                        }
                        
                        if (humidityStatusDiv) {
                            humidityStatusDiv.innerHTML = '<span class="text-green-500">Settings loaded ✓</span>';
                            setTimeout(() => {
                                humidityStatusDiv.innerHTML = '';
                            }, 3000);
                        }
                    } else {
                        console.error(`Error loading settings for ${deviceId}:`, data.error);
                        
                        // Try to recover settings from localStorage
                        if (tryRecoverSettings(deviceId)) {
                            // Show warning message
                            if (tempStatusDiv) tempStatusDiv.innerHTML = '<span class="text-yellow-500">Using stored settings</span>';
                            if (humidityStatusDiv) humidityStatusDiv.innerHTML = '<span class="text-yellow-500">Using stored settings</span>';
                            
                            showStatusMessage(`Could not load server settings. Using locally stored settings.`, 'warning');
                        } else {
                            // Show error message
                            if (tempStatusDiv) tempStatusDiv.innerHTML = '<span class="text-red-500">Load failed!</span>';
                            if (humidityStatusDiv) humidityStatusDiv.innerHTML = '<span class="text-red-500">Load failed!</span>';
                            
                            showStatusMessage(`Failed to load settings for ${deviceId}.`, 'error');
                        }
                    }
                } catch (error) {
                    console.error('Error loading device settings:', error);
                    
                    // Try to recover settings from localStorage
                    if (tryRecoverSettings(deviceId)) {
                        // Show warning message
                        if (tempStatusDiv) tempStatusDiv.innerHTML = '<span class="text-yellow-500">Using stored settings</span>';
                        if (humidityStatusDiv) humidityStatusDiv.innerHTML = '<span class="text-yellow-500">Using stored settings</span>';
                        
                        showStatusMessage(`Network error: ${error.message}. Using locally stored settings.`, 'warning');
                    } else {
                        // Show error message
                        if (tempStatusDiv) tempStatusDiv.innerHTML = '<span class="text-red-500">Load failed! ' + error.message + '</span>';
                        if (humidityStatusDiv) humidityStatusDiv.innerHTML = '<span class="text-red-500">Load failed! ' + error.message + '</span>';
                        
                        showStatusMessage(`Error loading settings: ${error.message}`, 'error');
                    }
                }
            } catch (error) {
                console.error('Error in loadDeviceSettings:', error);
                
                // Show error message
                const tempStatusDiv = document.getElementById(`temp-settings-status-${deviceId}`);
                const humidityStatusDiv = document.getElementById(`humidity-settings-status-${deviceId}`);
                if (tempStatusDiv) tempStatusDiv.innerHTML = '<span class="text-red-500">Load failed! ' + error.message + '</span>';
                if (humidityStatusDiv) humidityStatusDiv.innerHTML = '<span class="text-red-500">Load failed! ' + error.message + '</span>';
                
                showStatusMessage(`Error loading settings: ${error.message}`, 'error');
            }
        }
        
        // Function to load settings for each device
        function initializeDeviceSettings() {
            const allDevices = window.devices || [];
            if (!allDevices || allDevices.length === 0) {
                console.error('No devices available for loading settings');
                return;
            }
            console.log(`Loading settings for ${allDevices.length} devices...`);
            
            // Update the status label instead of creating a new element
            const statusLabel = document.getElementById('device-status-label');
            if (statusLabel) {
                statusLabel.textContent = 'Loading settings from server...';
                statusLabel.className = 'mb-4 py-3 px-4 rounded-lg text-center font-bold text-white text-lg shadow-lg bg-blue-600 border-2 border-blue-300 max-w-md mx-auto';
                statusLabel.classList.remove('hidden', 'opacity-0');
            }
            
            // Load settings for each device sequentially 
            const loadSettingsSequentially = async () => {
                try {
                    for (const device of allDevices) {
                        console.log(`Loading settings for device: ${device.device}`);
                        
                        // Clear localStorage for this device before loading fresh settings
                        // This ensures we don't use any cached values when force refreshing
                        // REMOVED: localStorage.removeItem(`device_settings_${device.device}`);
                        
                        await loadDeviceSettings(device.device, true); // Always force refresh from server
                        
                        // Make sure manual buttons state is updated after loading settings
                        updateManualButtons(device.device);
                        
                        // Short delay between devices
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    // Update status label when done
                    if (statusLabel) {
                        statusLabel.innerHTML = `
                            <div class="flex items-center justify-center">
                                <svg class="inline-block w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                </svg>
                                <span>Settings loaded from server</span>
                            </div>
                        `;
                        statusLabel.className = 'mb-4 py-3 px-4 rounded-lg text-center font-bold text-white text-lg shadow-lg bg-green-700 border-2 border-green-300 max-w-md mx-auto';
                        
                        // Hide the message after a few seconds
                        setTimeout(() => {
                            statusLabel.classList.add('opacity-0');
                            setTimeout(() => {
                                statusLabel.classList.add('hidden');
                            }, 500);
                        }, 3000);
                    }
                    
                    // Force update all manual buttons one more time
                    setTimeout(() => {
                        allDevices.forEach(device => {
                            updateManualButtons(device.device);
                        });
                    }, 1000);
                    
                } catch (error) {
                    console.error('Error loading settings:', error);
                    if (statusLabel) {
                        statusLabel.innerHTML = `
                            <div class="flex items-center justify-center">
                                <svg class="inline-block w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                                </svg>
                                <span>Error loading settings. Check your connection.</span>
                            </div>
                        `;
                        statusLabel.className = 'mb-4 py-3 px-4 rounded-lg text-center font-bold text-white text-lg shadow-lg bg-red-600 border-2 border-red-300 max-w-md mx-auto';
                    }
                }
            };
            
            loadSettingsSequentially();
            
            // Also initialize the reload settings button
            const reloadBtn = document.getElementById('reload-settings-btn');
            if (reloadBtn) {
                reloadBtn.addEventListener('click', () => {
                    console.log('Manually reloading settings...');
                    loadSettingsSequentially();
                });
            }
        }

        function fetchOutdoorTemperature(forceRefresh = false) {
            console.log('Fetching outdoor temperature data...');
            
            const outdoorTempElement = document.getElementById('outdoor-temp');
            const outdoorHumidityElement = document.getElementById('outdoor-humidity');
            const statusElement = document.getElementById('outdoor-data-status');
            
            if (statusElement) {
                statusElement.textContent = 'Fetching outdoor data...';
            }
            
            // Add timestamp to prevent caching
            const timestamp = new Date().getTime();
            
            // Add timeout for the request
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
            
            // Try fetching from both potential endpoints (root and /garage/ prefixed)
            // First try the /get_outdoor_data endpoint (root level)
            fetch(`/get_outdoor_data/?_=${timestamp}`, { signal: controller.signal })
                .then(response => {
                    if (!response.ok) {
                        // If first endpoint fails, try the /garage/get_outdoor_data endpoint
                        return fetch(`/garage/get_outdoor_data/?_=${timestamp}`, { signal: controller.signal });
                    }
                    return response;
                })
                .then(response => {
                    clearTimeout(timeoutId); // Clear the timeout if request succeeds
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        console.log('Outdoor data:', data);
                        
                        // Initialize temperature values (moved outside if block to fix scoping)
                        let tempF = null;
                        let tempC = null;
                        
                        // Update the display with outdoor temperature in both C and F
                        if (data.outdoor_temp !== null) {
                            // data.outdoor_temp is already in Fahrenheit from the backend
                            // Convert back to Celsius for display
                            tempF = parseFloat(data.outdoor_temp);
                            tempC = ((tempF - 32) * 5) / 9;
                            outdoorTempElement.textContent = `${tempC.toFixed(1)}°C / ${tempF}°F`;
                        } else {
                            outdoorTempElement.textContent = 'N/A';
                        }
                        
                        // Update the display with outdoor humidity
                        if (data.outdoor_humidity !== null) {
                            outdoorHumidityElement.textContent = `${data.outdoor_humidity}%`;
                        } else {
                            outdoorHumidityElement.textContent = 'N/A';
                        }
                        
                        // Update status with consistent format
                        if (statusElement) {
                            const now = new Date();
                            statusElement.textContent = `Last Updated: ${now.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}`;
                        }
                        
                        // Update all the additional weather data fields
                        updateWeatherDataFields(data);
                        
                        // Store the weather data point with timestamp
                        if (data.outdoor_temp !== null || data.outdoor_humidity !== null) {
                            const currentTime = new Date();
                            
                            // Add data point to history, checking for duplicates
                            const isDuplicate = window.outdoorWeatherHistory.some(point => 
                                Math.abs(point.timestamp - currentTime) < 60000 && // Within 1 minute
                                point.temperature === tempF &&
                                point.humidity === data.outdoor_humidity
                            );
                            
                            if (!isDuplicate) {
                                window.outdoorWeatherHistory.push({
                                    timestamp: currentTime,
                                    temperature: tempF,
                                    temperatureC: tempC,
                                    humidity: data.outdoor_humidity
                                });
                                
                                // Keep only data from the last 24 hours + a small buffer
                                const cutoffTime = new Date(currentTime.getTime() - (25 * 60 * 60 * 1000));
                                window.outdoorWeatherHistory = window.outdoorWeatherHistory.filter(point => 
                                    point.timestamp >= cutoffTime
                                );
                                
                                // Sort by timestamp to ensure chronological order
                                window.outdoorWeatherHistory.sort((a, b) => a.timestamp - b.timestamp);
                            }
                        }
                        
                        // Render outdoor temperature chart
                        try {
                            renderOutdoorChart();
                        } catch (chartError) {
                            console.error('Error rendering chart:', chartError);
                        }
                    } else {
                        console.error('Error fetching outdoor data:', data.error);
                        outdoorTempElement.textContent = 'N/A';
                        outdoorHumidityElement.textContent = 'N/A';
                        
                        // Also clear all additional weather data fields
                        clearWeatherDataFields();
                        
                        if (statusElement) {
                            statusElement.textContent = `Error: ${data.error || 'Unknown error'}`;
                            
                            // Auto-clear error message after 10 seconds
                            setTimeout(() => {
                                if (statusElement.textContent.includes('Error:')) {
                                    statusElement.textContent = 'Last Updated: --';
                                }
                            }, 10000);
                        }
                    }
                })
                .catch(error => {
                    clearTimeout(timeoutId); // Make sure to clear timeout
                    console.error('Error fetching outdoor data:', error);
                    
                    const errorMessage = error.name === 'AbortError' 
                        ? 'Request timed out' 
                        : `${error.message || 'Connection error'}`;
                        
                    outdoorTempElement.textContent = 'N/A';
                    outdoorHumidityElement.textContent = 'N/A';
                    
                    if (statusElement) {
                        statusElement.textContent = `Error: ${errorMessage}`;
                        
                        // Auto-clear error message after 10 seconds
                        setTimeout(() => {
                            if (statusElement.textContent.includes('Error:')) {
                                statusElement.textContent = 'Last Updated: --';
                            }
                        }, 10000);
                    }
                });
            
            // Refresh every 15 minutes
            if (!forceRefresh) {
                setTimeout(() => fetchOutdoorTemperature(), 15 * 60 * 1000);
            }
        }
        
        function renderOutdoorChart() {
            // Use real history data for the outdoor weather chart
            const ctx = document.getElementById('outdoorChart').getContext('2d');
            
            // Clear any existing chart - with proper error handling
            try {
                if (window.outdoorChart && typeof window.outdoorChart.destroy === 'function') {
                    window.outdoorChart.destroy();
                }
            } catch (error) {
                console.error('Error destroying existing chart:', error);
                // Continue with chart creation even if destroy fails
            }
            
            // Use our history data if available, otherwise create some demo data
            let labels = [];
            let tempData = [];
            let humidityData = [];
            
            if (window.outdoorWeatherHistory && window.outdoorWeatherHistory.length > 0) {
                // Use actual recorded data
                console.log(`Using ${window.outdoorWeatherHistory.length} real data points for outdoor chart`);
                
                // Sort data points by timestamp to ensure proper order
                const sortedData = [...window.outdoorWeatherHistory].sort((a, b) => a.timestamp - b.timestamp);
                
                // Only use the last 24 hours of data
                const now = new Date();
                const cutoffTime = new Date(now.getTime() - (24 * 60 * 60 * 1000));
                const filteredData = sortedData.filter(point => point.timestamp >= cutoffTime);
                
                // Handle any null values in the data
                const sanitizedData = sanitizeChartData(filteredData);
                
                // Ensure we have a consistent number of data points for both charts (24 points)
                const reducedData = reduceDataPoints(sanitizedData, 24);
                console.log(`Adjusted outdoor data points from ${filteredData.length} to ${reducedData.length}`);
                
                // Extract just the time part (no date) in a consistent format
                labels = reducedData.map(point => {
                    if (point.timestamp instanceof Date) {
                        return point.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    } else {
                        const time = new Date(point.timestamp);
                        return time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    }
                });
                
                tempData = reducedData.map(point => point.temperature);
                humidityData = reducedData.map(point => point.humidity);
            } else {
                // If no history data, use default behavior (the existing code for demo data)
                console.log('No history data available, creating sample data');
                // ... existing sample data generation code ...
            }
            
            // Final check for any missing values in outdoor data
            for (let i = 0; i < humidityData.length; i++) {
                if (humidityData[i] === null || humidityData[i] === undefined) {
                    console.warn(`Fixing null outdoor humidity value at index ${i}`);
                    // Find the nearest non-null value
                    let j = i - 1;
                    while (j >= 0 && (humidityData[j] === null || humidityData[j] === undefined)) {
                        j--;
                    }
                    if (j >= 0) {
                        humidityData[i] = humidityData[j]; // Use previous value
                    } else {
                        // If no previous value, look for next value
                        j = i + 1;
                        while (j < humidityData.length && (humidityData[j] === null || humidityData[j] === undefined)) {
                            j++;
                        }
                        humidityData[i] = j < humidityData.length ? humidityData[j] : 0;
                    }
                }
            }
            
            // Create the chart with both temperature and humidity
            window.outdoorChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Temperature (°F)',
                            data: tempData,
                            borderColor: 'rgba(16, 185, 129, 1)',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            borderWidth: 2,
                            pointRadius: 3,
                            pointBackgroundColor: 'rgba(16, 185, 129, 1)',
                            fill: true,
                            yAxisID: 'y-temp',
                            tension: 0.4,
                            spanGaps: true // Connect lines over null values
                        },
                        {
                            label: 'Humidity (%)',
                            data: humidityData,
                            borderColor: 'rgba(124, 58, 237, 1)',
                            backgroundColor: 'rgba(124, 58, 237, 0.1)',
                            borderWidth: 2,
                            pointRadius: 3,
                            pointBackgroundColor: 'rgba(124, 58, 237, 1)',
                            fill: true,
                            yAxisID: 'y-humidity',
                            tension: 0.4,
                            spanGaps: true // Connect lines over null values
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 15,
                                font: {
                                    size: 12
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            titleColor: '#334155',
                            bodyColor: '#334155',
                            borderColor: 'rgba(203, 213, 225, 1)',
                            borderWidth: 1,
                            padding: 10,
                            cornerRadius: 6,
                            displayColors: true,
                            usePointStyle: true,
                            callbacks: {
                                title: function(tooltipItems) {
                                    return tooltipItems[0].label;
                                }
                            }
                        }
                    },
                    scales: {
                        'y-temp': {
                            type: 'linear',
                            position: 'left',
                            grid: {
                                color: 'rgba(203, 213, 225, 0.4)'
                            },
                            ticks: {
                                font: {
                                    size: 11
                                }
                            },
                            title: { 
                                display: true, 
                                text: 'Temperature (°F)',
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                } 
                            }
                        },
                        'y-humidity': {
                            type: 'linear',
                            position: 'right',
                            min: 0,
                            max: 100,
                            grid: { 
                                drawOnChartArea: false,
                                color: 'rgba(203, 213, 225, 0.4)'
                            },
                            ticks: {
                                font: {
                                    size: 11
                                }
                            },
                            title: { 
                                display: true, 
                                text: 'Humidity (%)',
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                } 
                            }
                        },
                        x: {
                            grid: {
                                color: 'rgba(203, 213, 225, 0.4)'
                            },
                            ticks: {
                                maxTicksLimit: 12, // Standardize number of ticks on x-axis
                                font: {
                                    size: 11
                                },
                                callback: function(value, index, values) {
                                    // Ensure consistent time format display
                                    return labels[index];
                                }
                            }
                        }
                    }
                }
            });
            
            // Update the timestamp
            const outdoorChartTimestamp = document.getElementById('outdoor-chart-updated');
            if (outdoorChartTimestamp) {
                outdoorChartTimestamp.textContent = `Last updated: ${new Date().toLocaleTimeString([], {hour: '2-digit', minute: '2-digit', second: '2-digit'})}`;
            }
        }

        // Update the Current Reading section's time formatting
        function updateMainReadingTimestamp() {
            // Get the current timestamp element
            const timestampDisplay = document.getElementById('main-reading-timestamp');
            if (timestampDisplay) {
                const now = new Date();
                timestampDisplay.textContent = `Last Updated: ${now.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}`;
            }
        }

        // Function to fetch and update sensor data display
        function updateSensorData() {
            fetch('/api/sensor_data/?_=' + new Date().getTime())
                .then(response => response.json())
                .then(data => {
                    const indoorTemp = document.getElementById('indoor-temp');
                    const indoorHumidity = document.getElementById('indoor-humidity');
                    const statusElement = document.getElementById('main-reading-timestamp');
                    
                    console.log("Sensor data received:", JSON.stringify(data));
                    
                    // Handle temperature
                    if (data.status === 'offline' || data.temperature === null) {
                        // Display N/A for temperature when offline or null
                        if (indoorTemp) {
                            indoorTemp.textContent = 'N/A';
                            console.log("Set indoor temp to N/A");
                        }
                    } else {
                        // Normal temperature display when online
                        if (indoorTemp) {
                            const celsiusTemp = data.temperature;
                            const fahrenheitTemp = (celsiusTemp * 9/5) + 32;
                            indoorTemp.textContent = `${celsiusTemp.toFixed(1)}°C / ${fahrenheitTemp}°F`;
                        }
                    }
                    
                    // Handle humidity
                    if (data.status === 'offline' || data.humidity === null) {
                        // Display N/A for humidity when offline or null
                        if (indoorHumidity) {
                            indoorHumidity.textContent = 'N/A';
                            console.log("Set indoor humidity to N/A");
                        }
                    } else {
                        // Normal humidity display when online
                        if (indoorHumidity) {
                            indoorHumidity.textContent = `${data.humidity.toFixed(1)}%`;
                        }
                    }
                    
                    // Update status indicator
                    if (statusElement) {
                        if (data.status === 'offline') {
                            statusElement.textContent = 'Last Updated: ' + 
                                new Date().toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'}) + 
                                ' (SENSOR OFFLINE)';
                            statusElement.classList.add('text-red-500');
                        } else {
                            statusElement.textContent = 'Last Updated: ' + 
                                new Date().toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
                            statusElement.classList.remove('text-red-500');
                        }
                    }
                })
                .catch(error => {
                    console.error('Error fetching sensor data:', error);
                    // Set to N/A on error
                    const indoorTemp = document.getElementById('indoor-temp');
                    const indoorHumidity = document.getElementById('indoor-humidity');
                    if (indoorTemp) indoorTemp.textContent = 'N/A';
                    if (indoorHumidity) indoorHumidity.textContent = 'N/A';
                });
        }
        
        // Replace all calls to updateIndoorTemperatureDisplay with updateSensorData
        function updateIndoorTemperatureDisplay() {
            fetch('/api/sensor_data/?_=' + new Date().getTime())
                .then(response => response.json())
                .then(data => {
                    console.log('Updated indoor temperature data:', data);
                    
                    // Update timestamp
                    const timestampElement = document.getElementById('main-reading-timestamp');
                    if (timestampElement) {
                        timestampElement.textContent = 'Last Updated: ' + (data.timestamp || 'N/A');
                    }
                    
                    // Update or show N/A for temperature
                    const tempElement = document.getElementById('indoor-temp');
                    if (tempElement) {
                        if (data.status === 'offline' || data.temperature === null) {
                            tempElement.innerHTML = 'N/A';
                        } else {
                            const tempF = (data.temperature * 9/5) + 32;
                            tempElement.innerHTML = data.temperature.toFixed(1) + '°C / ' + tempF.toFixed(3) + '°F';
                        }
                    }
                    
                    // Update or show N/A for humidity
                    const humidityElement = document.getElementById('indoor-humidity');
                    if (humidityElement) {
                        if (data.status === 'offline' || data.humidity === null) {
                            humidityElement.innerHTML = 'N/A';
                        } else {
                            humidityElement.innerHTML = data.humidity.toFixed(1) + '%';
                        }
                    }
                    
                    // Update additional indoor sensor data
                    updateIndoorSensorDetails(data);
                })
                .catch(error => console.error('Error fetching indoor temperature:', error));
        }
        
        function updateIndoorSensorDetails(data) {
            // Update each field with data or 'N/A' if not available
            
            // Time
            const timeElement = document.getElementById('indoor-time');
            if (timeElement) {
                timeElement.textContent = data.timestamp || 'N/A';
            }
            
            // Dew Point
            const dewPointElement = document.getElementById('indoor-dew-point');
            if (dewPointElement) {
                if (data.dew_point === null || data.status === 'offline') {
                    dewPointElement.textContent = 'N/A';
                } else {
                    const dewPointF = data.dew_point_f;
                    dewPointElement.textContent = data.dew_point.toFixed(1) + '°C / ' + dewPointF.toFixed(1) + '°F';
                }
            }
            
            // Battery
            const batteryElement = document.getElementById('indoor-battery');
            if (batteryElement) {
                if (data.battery === null || data.status === 'offline') {
                    batteryElement.textContent = 'N/A';
                } else {
                    batteryElement.textContent = data.battery + '%';
                }
            }
            
            // Absolute Humidity
            const absHumidityElement = document.getElementById('indoor-abs-humidity');
            if (absHumidityElement) {
                if (data.abs_humidity === null || data.status === 'offline') {
                    absHumidityElement.textContent = 'N/A';
                } else {
                    absHumidityElement.textContent = data.abs_humidity.toFixed(1) + ' g/m³';
                }
            }
            
            // Steam Pressure
            const steamPressureElement = document.getElementById('indoor-steam-pressure');
            if (steamPressureElement) {
                if (data.steam_pressure === null || data.status === 'offline') {
                    steamPressureElement.textContent = 'N/A';
                } else {
                    steamPressureElement.textContent = data.steam_pressure.toFixed(1) + ' mbar';
                }
            }
            
            // Status
            const statusElement = document.getElementById('indoor-status');
            if (statusElement) {
                statusElement.textContent = data.status || 'N/A';
            }
        }

        // Add a function to disable/enable manual buttons based on automatic control state
        function updateManualButtons(deviceId) {
            console.log(`Updating manual button state for device ${deviceId}`);
            const tempToggle = document.getElementById(`temp-toggle-${deviceId}`);
            const humidityToggle = document.getElementById(`humidity-toggle-${deviceId}`);
            const onButton = document.querySelector(`[data-device="${deviceId}"][data-action="on"]`);
            const offButton = document.querySelector(`[data-device="${deviceId}"][data-action="off"]`);
            
            // Check if any automatic control is enabled
            const autoControlEnabled = (tempToggle && tempToggle.checked) || 
                                      (humidityToggle && humidityToggle.checked);
            
            // Update button state
            if (onButton && offButton) {
                if (autoControlEnabled) {
                    // Disable manual buttons when auto control is on
                    onButton.disabled = true;
                    offButton.disabled = true;
                    onButton.classList.add('opacity-50', 'cursor-not-allowed');
                    offButton.classList.add('opacity-50', 'cursor-not-allowed');
                    
                    // Make disabled state more visually obvious
                    onButton.style.pointerEvents = 'none';
                    offButton.style.pointerEvents = 'none';
                    
                    // Add a message explaining why buttons are disabled
                    const controlsContainer = onButton.closest('div').parentElement;
                    let messageDiv = document.getElementById(`auto-control-message-${deviceId}`);
                    
                    if (!messageDiv) {
                        messageDiv = document.createElement('div');
                        messageDiv.id = `auto-control-message-${deviceId}`;
                        messageDiv.className = 'text-orange-600 text-xs mt-1 text-center font-bold';
                        controlsContainer.insertBefore(messageDiv, onButton.closest('div').nextSibling);
                    }
                    
                    messageDiv.textContent = 'Manual controls disabled while automatic controls are active';
                } else {
                    // Enable manual buttons when auto control is off
                    onButton.disabled = false;
                    offButton.disabled = false;
                    onButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    offButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    
                    // Reset pointer events
                    onButton.style.pointerEvents = '';
                    offButton.style.pointerEvents = '';
                    
                    // Remove the message if it exists
                    const messageDiv = document.getElementById(`auto-control-message-${deviceId}`);
                    if (messageDiv) {
                        messageDiv.remove();
                    }
                }
            }
        }
        
        // Function to update all weather data fields
        function updateWeatherDataFields(data) {
            // Time field
            const timeElement = document.getElementById('weather-time');
            if (timeElement && data.time) {
                timeElement.textContent = data.time;
            }
            
            // Dew Point
            const dewPointElement = document.getElementById('weather-dew-point');
            if (dewPointElement && data.dew_point !== null) {
                let dewPoint = parseFloat(data.dew_point);
                let dewPointC = ((dewPoint - 32) * 5) / 9;
                dewPointElement.textContent = `${dewPointC.toFixed(1)}°C / ${dewPoint}°F`;
            }
            
            // Wind
            const windElement = document.getElementById('weather-wind');
            if (windElement && data.wind_direction) {
                windElement.textContent = data.wind_direction;
            }
            
            // Wind Speed
            const windSpeedElement = document.getElementById('weather-wind-speed');
            if (windSpeedElement && data.wind_speed !== null) {
                windSpeedElement.textContent = `${data.wind_speed} mph`;
            }
            
            // Wind Gust
            const gustElement = document.getElementById('weather-gust');
            if (gustElement && data.wind_gust !== null) {
                gustElement.textContent = `${data.wind_gust} mph`;
            }
            
            // Pressure
            const pressureElement = document.getElementById('weather-pressure');
            if (pressureElement && data.pressure !== null) {
                pressureElement.textContent = `${data.pressure} in`;
            }
            
            // Precipitation Rate
            const precipRateElement = document.getElementById('weather-precip-rate');
            if (precipRateElement && data.precip_rate !== null) {
                precipRateElement.textContent = `${data.precip_rate} in/hr`;
            }
            
            // Precipitation Accumulation
            const precipAccumElement = document.getElementById('weather-precip-accum');
            if (precipAccumElement && data.precip_accum !== null) {
                precipAccumElement.textContent = `${data.precip_accum} in`;
            }
            
            // UV
            const uvElement = document.getElementById('weather-uv');
            if (uvElement && data.uv !== null) {
                uvElement.textContent = data.uv;
            }
        }
        
        // Function to clear all weather data fields when data is unavailable
        function clearWeatherDataFields() {
            const fields = [
                'weather-time', 'weather-dew-point', 'weather-wind', 
                'weather-wind-speed', 'weather-gust', 'weather-pressure',
                'weather-precip-rate', 'weather-precip-accum', 'weather-uv'
            ];
            
            fields.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = '--';
                }
            });
        }

        // Add event listener for the refresh button
        document.addEventListener('DOMContentLoaded', function() {
            // Setup the refresh button event listener
            const refreshButton = document.getElementById('refresh-bluetooth-btn');
            if (refreshButton) {
                refreshButton.addEventListener('click', refreshBluetoothConnection);
            }
        });

        // Function to manually refresh the Bluetooth connection
        function refreshBluetoothConnection() {
            const refreshButton = document.getElementById('refresh-bluetooth-btn');
            
            // Disable button and show loading state
            if (refreshButton) {
                refreshButton.disabled = true;
                refreshButton.classList.add('opacity-50', 'cursor-not-allowed');
                refreshButton.innerHTML = `
                    <svg class="w-4 h-4 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                `;
            }
            
            // Show status message that we're refreshing
            showStatusMessage('Refreshing Bluetooth connection...', 'info');
            
            // Make POST request to the refresh_bluetooth endpoint
            fetch('/garage/refresh_bluetooth/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({})
            })
            .then(response => response.json())
            .then(data => {
                console.log('Bluetooth refresh result:', data);
                
                // Show refresh result in UI
                if (data.status === 'success') {
                    showStatusMessage('Success: Reconnected to sensor', 'success');
                    
                    // Immediately fetch new sensor data
                    updateIndoorTemperatureDisplay();
                } else {
                    showStatusMessage('Error: ' + data.message, 'error');
                }
            })
            .catch(error => {
                console.error('Error refreshing Bluetooth connection:', error);
                showStatusMessage('Error refreshing connection', 'error');
            })
            .finally(() => {
                // Re-enable button and restore original state
                if (refreshButton) {
                    refreshButton.disabled = false;
                    refreshButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    refreshButton.innerHTML = `
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                        </svg>
                    `;
                }
            });
        }

        // Helper function to get CSRF token from cookies
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        // Function to show status messages with auto-hide
        function showStatusMessage(message, type = 'success') {
            const statusLabel = document.getElementById('device-status-label');
            if (!statusLabel) return;
            
            // Clear any existing timeout
            if (window.statusMessageTimeout) {
                clearTimeout(window.statusMessageTimeout);
            }
            
            // Add style attribute for text shadow (better readability)
            statusLabel.style.textShadow = '0 0 4px rgba(0, 0, 0, 0.7)';
            
            // Set appropriate background color based on type
            statusLabel.classList.remove('bg-green-600', 'bg-green-700', 'bg-red-600', 'bg-blue-600', 'bg-yellow-600', 'border-white', 'border-green-300', 'border-red-300', 'border-blue-300', 'border-yellow-300');
            
            // Build message content with icon
            let iconSvg = '';
            
            switch (type) {
                case 'error':
                    statusLabel.classList.add('bg-red-600', 'border-red-300');
                    iconSvg = '<svg class="inline-block w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>';
                    break;
                case 'info':
                    statusLabel.classList.add('bg-blue-600', 'border-blue-300');
                    iconSvg = '<svg class="inline-block w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>';
                    break;
                case 'warning':
                    statusLabel.classList.add('bg-yellow-600', 'border-yellow-300');
                    iconSvg = '<svg class="inline-block w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg>';
                    break;
                default: // success
                    statusLabel.classList.add('bg-green-700', 'border-green-300');
                    iconSvg = '<svg class="inline-block w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>';
            }
            
            // Create message with icon and proper styling
            if (message.includes('OFF successfully')) {
                // Special high-contrast style for OFF messages
                statusLabel.innerHTML = `
                    <div class="flex items-center justify-center">
                        ${iconSvg}
                        <span class="bg-white text-green-800 px-3 py-1 rounded-md font-black">
                            ${message}
                        </span>
                    </div>
                `;
            } else if (message.includes('ON successfully')) {
                statusLabel.innerHTML = `
                    <div class="flex items-center justify-center">
                        ${iconSvg}
                        <span class="bg-white text-green-800 px-3 py-1 rounded-md font-black">
                            ${message}
                        </span>
                    </div>
                `;
            } else {
                statusLabel.innerHTML = `
                    <div class="flex items-center justify-center">
                        ${iconSvg}
                        <span>${message}</span>
                    </div>
                `;
            }
            
            // Show the message
            statusLabel.classList.remove('hidden', 'opacity-0');
            
            // Set timeout to hide the message after 5 seconds
            window.statusMessageTimeout = setTimeout(() => {
                statusLabel.classList.add('opacity-0');
                setTimeout(() => {
                    statusLabel.classList.add('hidden');
                }, 500);
            }, 5000);
        }

        // Add a helper function to ensure all device statuses use the same format
        function updateAllDeviceStatuses() {
            // Check if we have any devices loaded
            if (!window.devices || window.devices.length === 0) return;
            
            console.log("Checking for inconsistent status displays...");
            
            // Update all device statuses with a consistent format
            window.devices.forEach(device => {
                const deviceId = device.device;
                const statusDiv = document.getElementById(`device-status-${deviceId}`);
                if (!statusDiv) return;
                
                // Check if the current format doesn't match our LED style
                // (contains "Status:" text or doesn't have the rounded-full class)
                const needsUpdate = statusDiv.innerHTML.includes('Status:') || 
                                   !statusDiv.innerHTML.includes('rounded-full');
                
                if (needsUpdate) {
                    console.log(`Updating inconsistent status display for device ${deviceId}`);
                    
                    // Check if we have cached status for this device
                    const cachedStatus = window.deviceStatusCache[deviceId];
                    
                    if (cachedStatus) {
                        // Use the same LED-style format for all devices
                        const powerState = cachedStatus.power ? 'ON' : 'OFF';
                        const dotColor = cachedStatus.power ? 'bg-green-500' : 'bg-red-500';
                        const bgColor = cachedStatus.power ? 'bg-green-100' : 'bg-red-100';
                        const textColor = cachedStatus.power ? 'text-green-800' : 'text-red-800';
                        
                        statusDiv.innerHTML = `
                            <div class="flex items-center px-2 py-1 rounded-full ${bgColor} max-w-fit">
                                <span class="inline-block h-2.5 w-2.5 rounded-full ${dotColor} animate-pulse mr-1.5"></span>
                                <span class="font-medium ${textColor}">${powerState}</span>
                            </div>
                        `;
                    } else {
                        // No cached status, set to checking
                        statusDiv.innerHTML = `
                            <div class="flex items-center px-2 py-1 rounded-full bg-blue-100 max-w-fit">
                                <svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                <span class="font-medium text-blue-700">Checking status...</span>
                            </div>
                        `;
                        
                        // Force a refresh of this device's status
                        setTimeout(() => fetchDeviceStatus(deviceId, 'H5080'), 1000);
                    }
                }
            });
        }
        
        // Call this function periodically to catch any inconsistencies
        setInterval(updateAllDeviceStatuses, 5000);

        // Generate a unique client ID to identify this browser/device
        function generateClientId() {
            // Check if we already have a client ID in localStorage
            const existingClientId = localStorage.getItem('garage_client_id');
            if (existingClientId) {
                return existingClientId;
            }
            
            // Generate a new client ID using a combination of timestamp and random values
            const timestamp = new Date().getTime();
            const randomPart = Math.random().toString(36).substring(2, 10);
            const clientId = `device_${timestamp}_${randomPart}`;
            
            // Store it for future use
            try {
                localStorage.setItem('garage_client_id', clientId);
            } catch (e) {
                console.warn('Could not save client ID to localStorage:', e);
            }
            
            return clientId;
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Initialize the app on page load
            initializeApp();
        });
        
        // Sync interval to ensure devices stay in sync
        let syncTimer = null;
        const SYNC_INTERVAL = 60000; // 1 minute
        
        function initializeApp() {
            console.log('Initializing app...');
            
            // First load weather data if available
            loadCurrentWeather();
            
            // Load device readings
            loadDeviceReadings();
            
            // Initialize settings for all devices
            initializeDeviceSettings();
            
            // Set up sync timer to periodically check for setting changes
            if (syncTimer) {
                clearInterval(syncTimer);
            }
            
            syncTimer = setInterval(() => {
                checkForSettingsUpdates();
            }, SYNC_INTERVAL);
            
            // Also sync when the page becomes visible again (tab switching)
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    console.log('Page became visible, checking for settings updates...');
                    checkForSettingsUpdates();
                }
            });
            
            // Set up refresh for readings every 30 seconds
            setInterval(loadDeviceReadings, 30000);
        }
        
        // Function to check if settings need to be updated from server
        async function checkForSettingsUpdates() {
            try {
                // Skip if offline
                if (!navigator.onLine) {
                    console.log('Device is offline, skipping settings sync');
                    return;
                }
                
                console.log('Checking for settings updates from server...');
                const allDevices = window.devices || [];
                
                // Make a lightweight request to check for changes
                const clientId = generateClientId();
                const timestamp = Date.now();
                
                for (const device of allDevices) {
                    const deviceId = device.device;
                    try {
                        // Get local version info
                        let localVersion = 0;
                        try {
                            const storageKey = `device_settings_${deviceId}`;
                            const localSettings = localStorage.getItem(storageKey);
                            if (localSettings) {
                                const settingsObj = JSON.parse(localSettings);
                                localVersion = settingsObj.version || 0;
                            }
                        } catch (e) {
                            console.warn('Error reading local settings version:', e);
                        }
                        
                        // Create a URL that will return a 304 Not Modified response 
                        // if there are no updates, saving bandwidth
                        const checkUrl = `/get_device_settings/?device_id=${deviceId}&force_refresh=true&client_id=${clientId}&last_version=${localVersion}&check_only=true&_=${timestamp}`;
                        const response = await fetch(checkUrl, {
                            headers: { 
                                'Cache-Control': 'no-cache',
                                'If-None-Match': `"v${localVersion}"`
                            }
                        });
                        
                        if (response.status === 304) {
                            // 304 Not Modified - no changes needed
                            console.log(`Settings for device ${deviceId} are up to date (304 response)`);
                            continue;
                        }
                        
                        if (!response.ok) {
                            throw new Error(`Server error: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        
                        if (data.needs_update) {
                            console.log(`Settings for device ${deviceId} need update. Server: ${data.server_version}, Local: ${localVersion}`);
                            // Show syncing status message
                            showStatusMessage(`Syncing settings for ${deviceId}...`, 'info');
                            
                            // Force reload settings from server
                            await loadDeviceSettings(deviceId, true);
                            
                            showStatusMessage(`Settings synchronized from server`, 'success');
                        } else {
                            console.log(`Settings for device ${deviceId} are up to date (API response)`);
                        }
                    } catch (error) {
                        console.warn(`Error checking settings for ${deviceId}:`, error);
                    }
                }
            } catch (error) {
                console.error('Error in settings sync:', error);
            }
        }
        
        // Helper function to recover settings from local storage
        function tryRecoverSettings(deviceId) {
            try {
                const storageKey = `device_settings_${deviceId}`;
                const savedSettings = localStorage.getItem(storageKey);
                if (savedSettings) {
                    console.log('Attempting to recover settings from local storage');
                    const settings = JSON.parse(savedSettings);
                    
                    // Apply recovered settings
                    const tempToggle = document.getElementById(`temp-toggle-${deviceId}`);
                    if (tempToggle) {
                        tempToggle.checked = settings.temp_control_enabled;
                        // Show/hide controls
                        const tempControlsDiv = document.getElementById(`temp-controls-${deviceId}`);
                        if (tempControlsDiv) {
                            tempControlsDiv.classList.toggle('hidden', !settings.temp_control_enabled);
                        }
                    }
                    
                    // Apply source selection
                    const tempSources = document.querySelectorAll(`input[name="temp-source-${deviceId}"]`);
                    tempSources.forEach(radio => {
                        if (radio.value === settings.temp_source) {
                            radio.checked = true;
                        }
                    });
                    
                    // Apply min/max temperature
                    const minTempInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-temp-min"]`);
                    const maxTempInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-temp-max"]`);
                    if (minTempInput && settings.target_temp_min !== undefined) {
                        minTempInput.value = settings.target_temp_min;
                        // Also update the displayed value
                        const minTempDisplay = document.getElementById(`temp-min-value-${deviceId}`);
                        if (minTempDisplay) {
                            minTempDisplay.textContent = Math.round(settings.target_temp_min);
                        }
                    }
                    if (maxTempInput && settings.target_temp_max !== undefined) {
                        maxTempInput.value = settings.target_temp_max;
                        // Also update the displayed value
                        const maxTempDisplay = document.getElementById(`temp-max-value-${deviceId}`);
                        if (maxTempDisplay) {
                            maxTempDisplay.textContent = Math.round(settings.target_temp_max);
                        }
                    }
                    
                    // Apply temperature function
                    const tempFunctionSelect = document.querySelector(`[data-device="${deviceId}"][data-control="temp-function"]`);
                    if (tempFunctionSelect && settings.temp_range_type) {
                        tempFunctionSelect.value = settings.temp_range_type;
                    }
                    
                    // Handle humidity controls similarly
                    const humidityToggle = document.getElementById(`humidity-toggle-${deviceId}`);
                    if (humidityToggle) {
                        humidityToggle.checked = settings.humidity_control_enabled;
                        // Show/hide controls based on toggle state
                        const humidityControlsDiv = document.getElementById(`humidity-controls-${deviceId}`);
                        if (humidityControlsDiv) {
                            humidityControlsDiv.classList.toggle('hidden', !settings.humidity_control_enabled);
                        }
                    }
                    
                    // Apply humidity source selection
                    const humiditySources = document.querySelectorAll(`input[name="humidity-source-${deviceId}"]`);
                    humiditySources.forEach(radio => {
                        if (radio.value === settings.humidity_source) {
                            radio.checked = true;
                        }
                    });
                    
                    // Apply min/max humidity
                    const minHumidityInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-humidity-min"]`);
                    const maxHumidityInput = document.querySelector(`[data-device="${deviceId}"][data-control="target-humidity-max"]`);
                    if (minHumidityInput && settings.target_humidity_min !== undefined) {
                        minHumidityInput.value = settings.target_humidity_min;
                        // Also update the displayed value
                        const minHumidityDisplay = document.getElementById(`humidity-min-value-${deviceId}`);
                        if (minHumidityDisplay) {
                            minHumidityDisplay.textContent = Math.round(settings.target_humidity_min);
                        }
                    }
                    if (maxHumidityInput && settings.target_humidity_max !== undefined) {
                        maxHumidityInput.value = settings.target_humidity_max;
                        // Also update the displayed value
                        const maxHumidityDisplay = document.getElementById(`humidity-max-value-${deviceId}`);
                        if (maxHumidityDisplay) {
                            maxHumidityDisplay.textContent = Math.round(settings.target_humidity_max);
                        }
                    }
                    
                    // Apply humidity function
                    const humidityFunctionSelect = document.querySelector(`[data-device="${deviceId}"][data-control="humidity-function"]`);
                    if (humidityFunctionSelect && settings.humidity_range_type) {
                        humidityFunctionSelect.value = settings.humidity_range_type;
                    }
                    
                    console.log('Successfully recovered and applied settings from local storage');
                    
                    // Update the status labels
                    const tempStatusDiv = document.getElementById(`temp-settings-status-${deviceId}`);
                    const humidityStatusDiv = document.getElementById(`humidity-settings-status-${deviceId}`);
                    
                    if (tempStatusDiv) {
                        tempStatusDiv.innerHTML = '<span class="text-yellow-500">Using offline settings (not synced with server)</span>';
                    }
                    if (humidityStatusDiv) {
                        humidityStatusDiv.innerHTML = '<span class="text-yellow-500">Using offline settings (not synced with server)</span>';
                    }
                    
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Error recovering settings from local storage:', error);
                return false;
            }
        }
        
        // Function to load all device readings
        function loadDeviceReadings() {
            // Load current indoor temperature and humidity data
            updateIndoorTemperatureDisplay();
            
            // Load current outdoor temperature and humidity data
            fetchOutdoorTemperature();
            
            // Update display timestamps
            updateMainReadingTimestamp();
            
            // Update device statuses
            if (window.devices && window.devices.length > 0) {
                window.devices.forEach(device => {
                    fetchDeviceStatus(device.device, device.sku);
                });
            }
        }
        
        // Function to load current weather data for the loadCurrentWeather function referenced
        function loadCurrentWeather() {
            // Fetch outdoor temperature data first since it may be needed for device controls
            fetchOutdoorTemperature(true);
        }
    </script>
</body>
</html> 